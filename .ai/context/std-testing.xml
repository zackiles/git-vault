<repomix>This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, content has been formatted for parsing in xml style, content has been compressed (code blocks are separated by ⋮---- delimiter).<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: testing/**/*
- Files matching these patterns are excluded: testing/tests/**, testing/mocks/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Content has been formatted for parsing in xml style
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)</notes><additional_info></additional_info></file_summary><directory_structure>testing/
  __snapshots__/
    options_tests/
      custom_path.snap
      snapshot_test.ts.snap
    snapshot_test.ts.snap
  testdata/
    configure_global_sanitizers/
      disable_sanitize_exit.ts
      disable_sanitize_ops_and_resources.ts
      disable_sanitize_resources.ts
  _mock_utils.ts
  _snapshot_utils.ts
  _test_suite.ts
  _test_utils.ts
  _time.ts
  bdd_test.ts
  bdd.ts
  deno.json
  mock_test.ts
  mock.ts
  README.md
  snapshot_test.ts
  snapshot.ts
  time_test.ts
  time.ts
  types_test.ts
  types.ts
  unstable_bdd_test.ts
  unstable_bdd.ts
  unstable_snapshot_test.ts
  unstable_snapshot.ts
  unstable_stub_test.ts
  unstable_stub.ts
  unstable_types_test.ts
  unstable_types.ts</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path="testing/__snapshots__/options_tests/custom_path.snap">export const snapshot = {};

snapshot[`assertSnapshot() - options &gt; path &gt; relative 1`] = `
[
  1,
  2,
  3,
]
`;

snapshot[`assertSnapshot() - options &gt; path &gt; absolute 1`] = `
[
  1,
  2,
  3,
]
`;</file><file path="testing/__snapshots__/options_tests/snapshot_test.ts.snap">export const snapshot = {};

snapshot[`assertSnapshot() - options &gt; dir &gt; relative 1`] = `
[
  1,
  2,
  3,
]
`;

snapshot[`assertSnapshot() - options &gt; dir &gt; absolute 1`] = `
[
  1,
  2,
  3,
]
`;</file><file path="testing/__snapshots__/snapshot_test.ts.snap">export const snapshot = {};

snapshot[`assertSnapshot() 1`] = `
{
  a: 1,
  b: 2,
}
`;

snapshot[`assertSnapshot() 2`] = `
TestClass {
  a: 1,
  b: 2,
}
`;

snapshot[`assertSnapshot() 3`] = `
Map(3) {
  &quot;Hello&quot; =&gt; &quot;World!&quot;,
  1 =&gt; 2,
  [Function (anonymous)] =&gt; &quot;World!&quot;,
}
`;

snapshot[`assertSnapshot() 4`] = `
Set(3) {
  1,
  2,
  3,
}
`;

snapshot[`assertSnapshot() 5`] = `
{
  fn: [Function: fn],
}
`;

snapshot[`assertSnapshot() 6`] = `[Function: fn]`;

snapshot[`assertSnapshot() 7`] = `
[
  1,
  2,
  3,
]
`;

snapshot[`assertSnapshot() 8`] = `&quot;hello world&quot;`;

snapshot[`assertSnapshot() - step 1`] = `
{
  a: 1,
  b: 2,
}
`;

snapshot[`assertSnapshot() - step &gt; nested 1`] = `
TestClass {
  a: 1,
  b: 2,
}
`;

snapshot[`assertSnapshot() - step &gt; nested 2`] = `
Map(3) {
  &quot;Hello&quot; =&gt; &quot;World!&quot;,
  1 =&gt; 2,
  [Function (anonymous)] =&gt; &quot;World!&quot;,
}
`;

snapshot[`assertSnapshot() - step &gt; nested &gt; double-nested 1`] = `
Set(3) {
  1,
  2,
  3,
}
`;

snapshot[`assertSnapshot() - step &gt; nested &gt; double-nested 2`] = `
{
  fn: [Function: fn],
}
`;

snapshot[`assertSnapshot() - step &gt; nested &gt; double-nested 3`] = `[Function: fn]`;

snapshot[`assertSnapshot() - step &gt; nested 3`] = `
[
  1,
  2,
  3,
]
`;

snapshot[`assertSnapshot() - step 2`] = `&quot;hello world&quot;`;

snapshot[`assertSnapshot() - adverse string \\ \` \${} 1`] = `&quot;\\\\ \` \${}&quot;`;

snapshot[`assertSnapshot() - default serializer 1`] = `
&quot;a
b	c&quot;
`;

snapshot[`assertSnapshot() - multi-line strings &gt; string 1`] = `
&quot;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Snapshot Test - Multi-Line Strings&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;
      Snapshot Test - Multi-Line Strings
    &lt;/h2&gt;
    &lt;p&gt;
      This is a snapshot of a multi-line string.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;&quot;
`;

snapshot[`assertSnapshot() - multi-line strings &gt; string in array 1`] = `
[
  &quot;
&lt;h1&gt;
  Header
&lt;/h1&gt;&quot;,
  &quot;
&lt;p&gt;
  Content
&lt;/p&gt;&quot;,
]
`;

snapshot[`assertSnapshot() - multi-line strings &gt; string in object 1`] = `
{
  str: &quot;
        Line #1
        Line #2
        Line #3&quot;,
}
`;

snapshot[`assertSnapshot() - failed assertion &gt; object 1`] = `
&quot;Snapshot does not match:


    [Diff] Actual / Expected


    [
      1,
      2,
+     3,
    ]

To update snapshots, run
    deno test --allow-read --allow-write [files]... -- --update
&quot;
`;

snapshot[`assertSnapshot() - failed assertion &gt; string 1`] = `
&apos;Snapshot does not match:


    [Diff] Actual / Expected


-   &quot;Hello!&quot;
+   &quot;Hello World!&quot;


To update snapshots, run
    deno test --allow-read --allow-write [files]... -- --update
&apos;
`;

snapshot[`custom name 1`] = `
[
  1,
  2,
  3,
]
`;

snapshot[`custom name 2`] = `
[
  1,
  2,
  3,
]
`;

snapshot[`assertSnapshot() - options &gt; serializer 1`] = `
Array Length: 3

[
  1,
  2,
  3,
]
`;

snapshot[`assertSnapshot() - options &gt; msg &gt; missing snapshot 1`] = `&quot;[CUSTOM ERROR MESSAGE - MISSING SNAPSHOT]&quot;`;

snapshot[`assertSnapshot() - options &gt; msg &gt; missing snapshot file 1`] = `&quot;[CUSTOM ERROR MESSAGE - MISSING SNAPSHOT]&quot;`;

snapshot[`assertSnapshot() - options &gt; mode 1`] = `
&quot;
[
  1,
  2,
  3,
]
&quot;
`;

snapshot[`assertSnapshot() - options &gt; mode 2`] = `
&quot;running 1 test from &lt;tempDir&gt;/test.ts
snapshot ... ok (--ms)
------- post-test output -------

 &gt; 1 snapshot updated.
----- post-test output end -----

ok | 1 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - update - New snapshot 1`] = `
&quot;running 1 test from &lt;tempDir&gt;/test.ts
assertSnapshot() - update ... ok (--ms)
------- post-test output -------

 &gt; 1 snapshot updated.
----- post-test output end -----

ok | 1 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - update - New snapshot 2`] = `
&quot;export const snapshot = {};

snapshot[\`assertSnapshot() - update 1\`] = \`
[
  1,
  2,
]
\`;
&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshot - no changes 1`] = `
&quot;running 1 test from &lt;tempDir&gt;/test.ts
assertSnapshot() - update ... ok (--ms)

ok | 1 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshot - no changes 2`] = `
&quot;export const snapshot = {};

snapshot[\`assertSnapshot() - update 1\`] = \`
[
  1,
  2,
]
\`;
&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshot - updates 1`] = `
&quot;running 1 test from &lt;tempDir&gt;/test.ts
assertSnapshot() - update ... ok (--ms)
------- post-test output -------

 &gt; 1 snapshot updated.
----- post-test output end -----

ok | 1 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshot - updates 2`] = `
&quot;export const snapshot = {};

snapshot[\`assertSnapshot() - update 1\`] = \`
[
  1,
  2,
  3,
  5,
]
\`;
&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 1 1`] = `
&quot;running 2 tests from &lt;tempDir&gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------

 &gt; 2 snapshots updated.

 &gt; 1 snapshot removed.
   • assertSnapshot() - update 1
----- post-test output end -----

ok | 2 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 1 2`] = `
&apos;export const snapshot = {};

snapshot[\`Snapshot Test - First 1\`] = \`&quot;FIRST&quot;\`;

snapshot[\`Snapshot Test - Second 1\`] = \`&quot;SECOND&quot;\`;
&apos;
`;

snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 2 1`] = `
&quot;running 2 tests from &lt;tempDir&gt;/test.ts
Snapshot Test - Second ... ok (--ms)
Snapshot Test - First ... ok (--ms)

ok | 2 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - update - Existing snapshots - reverse order 2 2`] = `
&apos;export const snapshot = {};

snapshot[\`Snapshot Test - Second 1\`] = \`&quot;SECOND&quot;\`;

snapshot[\`Snapshot Test - First 1\`] = \`&quot;FIRST&quot;\`;
&apos;
`;

snapshot[`assertSnapshot() - remove - New snapshot 1`] = `
&quot;running 5 tests from &lt;tempDir&gt;/test.ts
assertSnapshot() - remove - First ... ok (--ms)
assertSnapshot() - remove - Second ... ok (--ms)
assertSnapshot() - remove - Third ... ok (--ms)
assertSnapshot() - remove - Fourth ... ok (--ms)
assertSnapshot() - remove - Fifth ... ok (--ms)
------- post-test output -------

 &gt; 5 snapshots updated.
----- post-test output end -----

ok | 5 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - remove - Existing snapshot - removed one 1`] = `
&quot;running 4 tests from &lt;tempDir&gt;/test.ts
assertSnapshot() - remove - First ... ok (--ms)
assertSnapshot() - remove - Second ... ok (--ms)
assertSnapshot() - remove - Fourth ... ok (--ms)
assertSnapshot() - remove - Fifth ... ok (--ms)
------- post-test output -------

 &gt; 1 snapshot removed.
   • assertSnapshot() - remove - Third 1
----- post-test output end -----

ok | 4 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - remove - Existing snapshot - removed several 1`] = `
&quot;running 1 test from &lt;tempDir&gt;/test.ts
assertSnapshot() - remove - First ... ok (--ms)
------- post-test output -------

 &gt; 3 snapshots removed.
   • assertSnapshot() - remove - Second 1
   • assertSnapshot() - remove - Fourth 1
   • assertSnapshot() - remove - Fifth 1
----- post-test output end -----

ok | 1 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - different directory - New snapshot 1`] = `
&quot;running 2 tests from &lt;tempDir&gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------

 &gt; 2 snapshots updated.
----- post-test output end -----
running 2 tests from &lt;tempDir&gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------

 &gt; 2 snapshots updated.
----- post-test output end -----

ok | 4 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - different directory - Existing snapshot - update 1`] = `
&quot;running 2 tests from &lt;tempDir&gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------

 &gt; some snapshots updated.
----- post-test output end -----
running 2 tests from &lt;tempDir&gt;/test.ts
Snapshot Test - First ... ok (--ms)
Snapshot Test - Second ... ok (--ms)
------- post-test output -------

 &gt; some snapshots updated.
----- post-test output end -----

ok | 4 passed | 0 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - regression #2140 1`] = `
{
  content: &quot;
      &lt;h1&gt;Testing a page&lt;/h1&gt;
      &lt;p&gt;This is a test&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        &lt;li&gt;4&lt;/li&gt;
      &lt;/ul&gt;
      &quot;,
  title: &quot;Testing a page&quot;,
}
`;

snapshot[`assertSnapshot() - regression #2144 1`] = `
{
  fmt: {
    files: {
      exclude: [],
      include: [],
    },
    options: {},
  },
}
`;

snapshot[`assertSnapshot() - empty #2245 1`] = ``;

snapshot[`createAssertSnapshot() &gt; no options 1`] = `This green text has had its colors stripped`;

snapshot[`createAssertSnapshot() - options object - custom name 1`] = `This green text has had its colors stripped`;

snapshot[`createAssertSnapshot() &gt; message 1`] = `&quot;This snapshot has failed as expected&quot;`;

snapshot[`createAssertSnapshot() - composite - custom Name 1`] = `This green text has had its colors stripped`;

snapshot[`assertSnapshot() - regression #5155 1`] = `
&quot;running 1 test from &lt;tempDir&gt;/test.ts
Snapshot Test ... FAILED (--ms)

 ERRORS 
error: PermissionDenied: Missing write access to snapshot file (file://&lt;path&gt;). This is required because assertSnapshot was called in update mode. Please pass the --allow-write flag.
        throw new Deno.errors.PermissionDenied(
              ^
 FAILURES 

FAILED | 0 passed | 1 failed (--ms)

&quot;
`;

snapshot[`assertSnapshot() - should work with the string with &apos;\\r&apos; character 1`] = `
&quot;Hello\\r
World!\\r
&quot;
`;</file><file path="testing/testdata/configure_global_sanitizers/disable_sanitize_exit.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { describe, it } from &quot;@std/testing/bdd&quot;;
import { configureGlobalSanitizers } from &quot;@std/testing/unstable-bdd&quot;;</file><file path="testing/testdata/configure_global_sanitizers/disable_sanitize_ops_and_resources.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { describe, it } from &quot;@std/testing/bdd&quot;;
import { configureGlobalSanitizers } from &quot;@std/testing/unstable-bdd&quot;;</file><file path="testing/testdata/configure_global_sanitizers/disable_sanitize_resources.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { describe, it } from &quot;@std/testing/bdd&quot;;
import { configureGlobalSanitizers } from &quot;@std/testing/unstable-bdd&quot;;</file><file path="testing/_mock_utils.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import type { Spy } from &quot;./mock.ts&quot;;
/**
 * Checks if a function is a spy.
 *
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @param func The function to check
 * @return `true` if the function is a spy, `false` otherwise.
 */
export function isSpy&lt;Self, Args extends unknown[], Return&gt;(
  func: ((this: Self, ...args: Args) =&gt; Return) | unknown,
): func is Spy&lt;Self, Args, Return&gt;
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
function getSession(): Set&lt;Spy&lt;any, any[], any&gt;&gt;
// deno-lint-ignore no-explicit-any
export function registerMock(spy: Spy&lt;any, any[], any&gt;)
// deno-lint-ignore no-explicit-any
export function unregisterMock(spy: Spy&lt;any, any[], any&gt;)</file><file path="testing/_snapshot_utils.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import type { SnapshotMode, SnapshotOptions } from &quot;./snapshot.ts&quot;;
import { diff } from &quot;@std/internal/diff&quot;;
import { diffStr } from &quot;@std/internal/diff-str&quot;;
import { buildMessage } from &quot;@std/internal/build-message&quot;;
export function getErrorMessage(message: string, options: SnapshotOptions)
/**
 * Default serializer for `assertSnapshot`.
 *
 * @example Usage
 * ```ts
 * import { serialize } from &quot;@std/testing/snapshot&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * assertEquals(serialize({ foo: 42 }), &quot;{\n  foo: 42,\n}&quot;)
 * ```
 *
 * @param actual The value to serialize
 * @returns The serialized string
 */
export function serialize(actual: unknown): string
/**
 * Converts a string to a valid JavaScript string which can be wrapped in backticks.
 *
 * @example
 *
 * &quot;special characters (\ ` $) will be escaped&quot; -&gt; &quot;special characters (\\ \` \$) will be escaped&quot;
 */
export function escapeStringForJs(str: string)
⋮----
/**
 * Get the snapshot mode.
 */
export function getMode(options: SnapshotOptions)
/**
 * Return `true` when snapshot mode is `update`.
 */
export function getIsUpdate(options: SnapshotOptions)
export function getOptions&lt;T&gt;(
  msgOrOpts?: string | T,
): T
export function getSnapshotNotMatchMessage(
  actualSnapshot: string,
  expectedSnapshot: string,
  options: SnapshotOptions,
)
// TODO (WWRS): Remove this when we drop support for Deno 1.x</file><file path="testing/_test_suite.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { getAssertionState } from &quot;@std/internal/assertion-state&quot;;
import { AssertionError } from &quot;@std/assert/assertion-error&quot;;
⋮----
/** The options for creating a test suite with the describe function. */
export interface DescribeDefinition&lt;T&gt; extends Omit&lt;Deno.TestDefinition, &quot;fn&quot;&gt; {
  /** The body of the test suite */
  fn?: () =&gt; void | undefined;
  /**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `describe` is called within another `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `describe` is not called within another `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
  suite?: TestSuite&lt;T&gt;;
  /** Run some shared setup before all of the tests in the suite. */
  beforeAll?:
    | ((this: T) =&gt; void | Promise&lt;void&gt;)
    | ((this: T) =&gt; void | Promise&lt;void&gt;)[];
  /** Run some shared teardown after all of the tests in the suite. */
  afterAll?:
    | ((this: T) =&gt; void | Promise&lt;void&gt;)
    | ((this: T) =&gt; void | Promise&lt;void&gt;)[];
  /** Run some shared setup before each test in the suite. */
  beforeEach?:
    | ((this: T) =&gt; void | Promise&lt;void&gt;)
    | ((this: T) =&gt; void | Promise&lt;void&gt;)[];
  /** Run some shared teardown after each test in the suite. */
  afterEach?:
    | ((this: T) =&gt; void | Promise&lt;void&gt;)
    | ((this: T) =&gt; void | Promise&lt;void&gt;)[];
}
⋮----
/** The body of the test suite */
⋮----
/**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `describe` is called within another `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `describe` is not called within another `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
⋮----
/** Run some shared setup before all of the tests in the suite. */
⋮----
/** Run some shared teardown after all of the tests in the suite. */
⋮----
/** Run some shared setup before each test in the suite. */
⋮----
/** Run some shared teardown after each test in the suite. */
⋮----
/** The options for creating an individual test case with the it function. */
export interface ItDefinition&lt;T&gt; extends Omit&lt;Deno.TestDefinition, &quot;fn&quot;&gt; {
  /** The body of the test case */
  fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;;
  /**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `it` is called within a `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `it` is not called within a `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
  suite?: TestSuite&lt;T&gt;;
}
⋮----
/** The body of the test case */
⋮----
/**
   * The `describe` function returns a `TestSuite` representing the group of tests.
   * If `it` is called within a `describe` calls `fn`, the suite will default to that parent `describe` calls returned `TestSuite`.
   * If `it` is not called within a `describe` calls `fn`, the suite will default to the `TestSuite` representing the global group of tests.
   */
⋮----
/** The names of all the different types of hooks. */
export type HookNames = &quot;beforeAll&quot; | &quot;afterAll&quot; | &quot;beforeEach&quot; | &quot;afterEach&quot;;
/**
 * A group of tests.
 */
export interface TestSuite&lt;T&gt; {
  /** The symbol to use for grouping the test suite */
  symbol: symbol;
}
⋮----
/** The symbol to use for grouping the test suite */
⋮----
/**
 * An internal representation of a group of tests.
 */
export class TestSuiteInternal&lt;T&gt; implements TestSuite&lt;T&gt;
⋮----
constructor(describe: DescribeDefinition&lt;T&gt;)
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Stores how many test suites are executing. */
⋮----
/** If a test has been registered yet. Block adding global hooks if a test has been registered. */
⋮----
/** A map of all test suites by symbol. */
// deno-lint-ignore no-explicit-any
⋮----
/** The current test suite being registered. */
// deno-lint-ignore no-explicit-any
⋮----
/** The stack of tests that are actively running. */
⋮----
/** This is used internally for testing this module. */
static reset()
/** This is used internally to register tests. */
static registerTest(options: Deno.TestDefinition)
/** Updates all steps within top level suite to have ignore set to true if only is not set to true on step. */
static addingOnlyStep&lt;T&gt;(suite: TestSuiteInternal&lt;T&gt;)
/** This is used internally to add steps to a test suite. */
static addStep&lt;T&gt;(
    suite: TestSuiteInternal&lt;T&gt;,
    step: TestSuiteInternal&lt;T&gt; | ItDefinition&lt;T&gt;,
)
/** This is used internally to add hooks to a test suite. */
static setHook&lt;T&gt;(
    suite: TestSuiteInternal&lt;T&gt;,
    name: HookNames,
    fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/** This is used internally to run all steps for a test suite. */
static async run&lt;T&gt;(
    suite: TestSuiteInternal&lt;T&gt;,
    context: T,
    t: Deno.TestContext,
)
⋮----
// deno-lint-ignore deno-style-guide/error-message
⋮----
static async runTest&lt;T&gt;(
    t: Deno.TestContext,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
    context: T,
    activeIndex = 0,
)</file><file path="testing/_test_utils.ts">// Copyright 2018-2025 the Deno authors. MIT license.
export class Point
⋮----
constructor(x: number, y: number)
// deno-lint-ignore no-explicit-any
action(...args: any[]): any
toString(): string
explicitTypes(_x: number, _y: string)
⋮----
export function stringifyPoint(point: Point)
export type PointWithExtra = Point &amp; {
  nonExistent: () =&gt; number;
};</file><file path="testing/_time.ts">// Copyright 2018-2025 the Deno authors. MIT license.
/** Used internally for testing that fake time uses real time correctly. */</file><file path="testing/bdd_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import {
  assert,
  assertEquals,
  assertObjectMatch,
  assertRejects,
  assertStrictEquals,
  assertThrows,
} from &quot;@std/assert&quot;;
import {
  after,
  afterAll,
  afterEach,
  before,
  beforeAll,
  beforeEach,
  describe,
  it,
} from &quot;./bdd.ts&quot;;
import { TestSuiteInternal } from &quot;./_test_suite.ts&quot;;
import { assertSpyCall, assertSpyCalls, type Spy, spy, stub } from &quot;./mock.ts&quot;;
class TestContext implements Deno.TestContext
⋮----
constructor(name: string)
async step(t: Deno.TestStepDefinition): Promise&lt;boolean&gt;;
async step(
    name: string,
    fn: (t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ): Promise&lt;boolean&gt;;
async step(
    fn: (t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ): Promise&lt;boolean&gt;;
async step(
    tOrNameOrFn:
      | Deno.TestStepDefinition
      | string
      | ((t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;),
    fn?: (t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
): Promise&lt;boolean&gt;
⋮----
interface GlobalContext {
  allTimer: number;
  eachTimer: number;
  x?: number;
  y?: number;
}
⋮----
function hookFns()
⋮----
/**
   * Asserts that `Deno.test` is called with the correct options for the `it` call in the callback function.
   * This is used to reduce code duplication when testing calling `it` with different call signatures.
   */
async function assertOptions&lt;T&gt;(
    expectedOptions: Omit&lt;Deno.TestDefinition, &quot;name&quot; | &quot;fn&quot;&gt;,
    cb: (fn: Spy) =&gt; void,
)
/**
   * Asserts that `Deno.test` is called with just the name and function for the `it` call in the callback function.
   * This is used to reduce code duplication when testing calling `it` with different call signatures.
   */
async function assertMinimumOptions(
    cb: (fn: Spy) =&gt; void,
)
/**
   * Asserts that `Deno.test` is called with all of the options for the `it` call in the callback function.
   * This is used to reduce code duplication when testing calling `it` with different call signatures.
   */
async function assertAllOptions(
    cb: (fn: Spy) =&gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with just the name, only, and function for the `it.only` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.only` with different call signatures.
     */
async function assertMinimumOptions(
      cb: (fn: Spy) =&gt; void,
)
/**
     * Asserts that `Deno.test` is called with all of the options for the `it.only` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.only` with different call signatures.
     */
async function assertAllOptions(
      cb: (fn: Spy) =&gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with just the name, ignore, and function for the `it.ignore` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that `Deno.test` is called with all of the options for the `it.ignore` call in the callback function.
     * This is used to reduce code duplication when testing calling `it.ignore` with different call signatures.
     */
⋮----
/**
   * Asserts that `Deno.test` is called with the correct options for the `describe` call in the callback function.
   * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
   * This is used to reduce code duplication when testing calling `describe` with different call signatures.
   */
async function assertOptions(
    expectedOptions: Omit&lt;Deno.TestDefinition, &quot;name&quot; | &quot;fn&quot;&gt;,
    cb: (fns: readonly [Spy, Spy]) =&gt; void,
)
/**
   * Asserts that `Deno.test` is called with just the name and function for the `describe` call in the callback function.
   * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
   * This is used to reduce code duplication when testing calling `describe` with different call signatures.
   */
async function assertMinimumOptions(
    cb: (fns: readonly [Spy, Spy]) =&gt; void,
)
/**
   * Asserts that `Deno.test` is called with all of the options for the `describe` call in the callback function.
   * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
   * This is used to reduce code duplication when testing calling `describe` with different call signatures.
   */
async function assertAllOptions(
    cb: (fns: readonly [Spy, Spy]) =&gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with just the name, only, and function for the `describe.only` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.only` with different call signatures.
     */
async function assertMinimumOptions(
      cb: (fns: readonly [Spy, Spy]) =&gt; void,
)
/**
     * Asserts that `Deno.test` is called with all of the options for the `describe.only` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.only` with different call signatures.
     */
async function assertAllOptions(
      cb: (fns: readonly [Spy, Spy]) =&gt; void,
)
⋮----
/**
     * Asserts that `Deno.test` is called with the correct options for the `describe` call in the callback function.
     * This is used to reduce code duplication when testing calling `describe` with different call signatures.
     */
async function assertIgnoreOptions(
      expectedOptions: Omit&lt;Deno.TestDefinition, &quot;name&quot; | &quot;fn&quot;&gt;,
      cb: (fns: readonly [Spy, Spy]) =&gt; void,
)
/**
     * Asserts that `Deno.test` is called with just the name, ignore, and function for the `describe.ignore` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that `Deno.test` is called with all of the options for the `describe.ignore` call in the callback function.
     * In addition to that, it asserts that the individual test cases registered with `it` use the test step API correctly.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that when only is used on a nested `describe` or `it` call, it will be the only test case or suite that runs in the file.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
async function assertOnly(
      cb: (fns: readonly [Spy, Spy, Spy]) =&gt; void,
)
⋮----
/**
     * Asserts that when only is used on a child `describe` or `it` call, it will be the only test case or suite that runs within the top test suite.
     * This demonstrates the issue where `Deno.test` is called without `only` even though one of its child steps are focused.
     * This is used to reduce code duplication when testing calling `describe.ignore` with different call signatures.
     */
⋮----
/**
     * Asserts that all the different hook types are called in the correct order when the tests run.
     * This is used to reduce code duplication when testing calling `describe` with different call signatures.
     */
async function assertHooks(
      cb: (
        options: {
          beforeAllFn: Spy;
          afterAllFn: Spy;
          beforeEachFn: Spy;
          afterEachFn: Spy;
          fns: readonly [Spy, Spy];
        },
      ) =&gt; void,
)
⋮----
interface NestedContext extends GlobalContext {
      allTimerNested: number;
      eachTimerNested: number;
      x: number;
      y: number;
    }
⋮----
it(
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// TODO(kt3k): This case should be type error but it&apos;s checked as
// DescribeDefinition&lt;T&gt; and passes the type check
// describe(async function example() {});
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// @ts-expect-error async function is not assignable to describe argument
⋮----
// Ignores runtime errors as this case is for static type checking
⋮----
// deno-lint-ignore no-explicit-any</file><file path="testing/bdd.ts">// Copyright 2018-2025 the Deno authors. MIT license.
/**
 * A {@link https://en.wikipedia.org/wiki/Behavior-driven_development | BDD} interface
 * to `Deno.test()` API.
 *
 * With `@std/testing/bdd` module you can write your tests in a familiar format for
 * grouping tests and adding setup/teardown hooks used by other JavaScript testing
 * frameworks like Jasmine, Jest, and Mocha.
 *
 * The `describe` function creates a block that groups together several related
 * tests. The `it` function registers an individual test case.
 *
 * ## Hooks
 *
 * There are 4 types of hooks available for test suites. A test suite can have
 * multiples of each type of hook, they will be called in the order that they are
 * registered. The `afterEach` and `afterAll` hooks will be called whether or not
 * the test case passes. The *All hooks will be called once for the whole group
 * while the *Each hooks will be called for each individual test case.
 *
 * - `beforeAll`: Runs before all of the tests in the group.
 * - `afterAll`: Runs after all of the tests in the group finish.
 * - `beforeEach`: Runs before each of the individual test cases in the group.
 * - `afterEach`: Runs after each of the individual test cases in the group.
 *
 * If a hook is registered at the top level, a global test suite will be registered
 * and all tests will belong to it. Hooks registered at the top level must be
 * registered before any individual test cases or test suites.
 *
 * ## Focusing tests
 *
 * If you would like to run only specific test cases, you can do so by calling
 * `it.only` instead of `it`. If you would like to run only specific test suites,
 * you can do so by calling `describe.only` instead of `describe`.
 *
 * There is one limitation to this when using the flat test grouping style. When
 * `describe` is called without being nested, it registers the test with
 * `Deno.test`. If a child test case or suite is registered with `it.only` or
 * `describe.only`, it will be scoped to the top test suite instead of the file. To
 * make them the only tests that run in the file, you would need to register the
 * top test suite with `describe.only` too.
 *
 * ## Ignoring tests
 *
 * If you would like to not run specific individual test cases, you can do so by
 * calling `it.ignore` instead of `it`. If you would like to not run specific test
 * suites, you can do so by calling `describe.ignore` instead of `describe`.
 *
 * ## Sanitization options
 *
 * Like `Deno.TestDefinition`, the `DescribeDefinition` and `ItDefinition` have
 * sanitization options. They work in the same way.
 *
 * - `sanitizeExit`: Ensure the test case does not prematurely cause the process to
 *   exit, for example via a call to Deno.exit. Defaults to true.
 * - `sanitizeOps`: Check that the number of async completed ops after the test is
 *   the same as number of dispatched ops. Defaults to true.
 * - `sanitizeResources`: Ensure the test case does not &quot;leak&quot; resources - ie. the
 *   resource table after the test has exactly the same contents as before the
 *   test. Defaults to true.
 *
 * ## Permissions option
 *
 * Like `Deno.TestDefinition`, the `DescribeDefinition` and `ItDefinition` have a
 * `permissions` option. They specify the permissions that should be used to run an
 * individual test case or test suite. Set this to `&quot;inherit&quot;` to keep the calling
 * thread&apos;s permissions. Set this to `&quot;none&quot;` to revoke all permissions.
 *
 * This setting defaults to `&quot;inherit&quot;`.
 *
 * There is currently one limitation to this, you cannot use the permissions option
 * on an individual test case or test suite that belongs to another test suite.
 * That&apos;s because internally those tests are registered with `t.step` which does
 * not support the permissions option.
 *
 * ## Comparing to Deno\.test
 *
 * The default way of writing tests is using `Deno.test` and `t.step`. The
 * `describe` and `it` functions have similar call signatures to `Deno.test`,
 * making it easy to switch between the default style and the behavior-driven
 * development style of writing tests. Internally, `describe` and `it` are
 * registering tests with `Deno.test` and `t.step`.
 *
 * Below is an example of a test file using `Deno.test` and `t.step`. In the
 * following sections there are examples of how the same test could be written with
 * `describe` and `it` using nested test grouping, flat test grouping, or a mix of
 * both styles.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &quot;@std/assert&quot;;
 *
 * class User {
 *   static users: Map&lt;string, User&gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&quot;Age unknown&quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * Deno.test(&quot;User.users initially empty&quot;, () =&gt; {
 *   assertEquals(User.users.size, 0);
 * });
 *
 * Deno.test(&quot;User constructor&quot;, () =&gt; {
 *   try {
 *     const user = new User(&quot;Kyle&quot;);
 *     assertEquals(user.name, &quot;Kyle&quot;);
 *     assertStrictEquals(User.users.get(&quot;Kyle&quot;), user);
 *   } finally {
 *     User.users.clear();
 *   }
 * });
 *
 * Deno.test(&quot;User age&quot;, async (t) =&gt; {
 *   const user = new User(&quot;Kyle&quot;);
 *
 *   await t.step(&quot;getAge&quot;, () =&gt; {
 *     assertThrows(() =&gt; user.getAge(), Error, &quot;Age unknown&quot;);
 *     user.age = 18;
 *     assertEquals(user.getAge(), 18);
 *   });
 *
 *   await t.step(&quot;setAge&quot;, () =&gt; {
 *     user.setAge(18);
 *     assertEquals(user.getAge(), 18);
 *   });
 * });
 * ```
 *
 * ### Nested test grouping
 *
 * Tests created within the callback of a `describe` function call will belong to
 * the new test suite it creates. The hooks can be created within it or be added to
 * the options argument for describe.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &quot;@std/assert&quot;;
 * import {
 *   afterEach,
 *   beforeEach,
 *   describe,
 *   it,
 * } from &quot;@std/testing/bdd&quot;;
 *
 * class User {
 *   static users: Map&lt;string, User&gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&quot;Age unknown&quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * describe(&quot;User&quot;, () =&gt; {
 *   it(&quot;users initially empty&quot;, () =&gt; {
 *     assertEquals(User.users.size, 0);
 *   });
 *
 *   it(&quot;constructor&quot;, () =&gt; {
 *     try {
 *       const user = new User(&quot;Kyle&quot;);
 *       assertEquals(user.name, &quot;Kyle&quot;);
 *       assertStrictEquals(User.users.get(&quot;Kyle&quot;), user);
 *     } finally {
 *       User.users.clear();
 *     }
 *   });
 *
 *   describe(&quot;age&quot;, () =&gt; {
 *     let user: User;
 *
 *     beforeEach(() =&gt; {
 *       user = new User(&quot;Kyle&quot;);
 *     });
 *
 *     afterEach(() =&gt; {
 *       User.users.clear();
 *     });
 *
 *     it(&quot;getAge&quot;, function () {
 *       assertThrows(() =&gt; user.getAge(), Error, &quot;Age unknown&quot;);
 *       user.age = 18;
 *       assertEquals(user.getAge(), 18);
 *     });
 *
 *     it(&quot;setAge&quot;, function () {
 *       user.setAge(18);
 *       assertEquals(user.getAge(), 18);
 *     });
 *   });
 * });
 * ```
 *
 * ### Flat test grouping
 *
 * The `describe` function returns a unique symbol that can be used to reference
 * the test suite for adding tests to it without having to create them within a
 * callback. The gives you the ability to have test grouping without any extra
 * indentation in front of the grouped tests.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &quot;@std/assert&quot;;
 * import {
 *   describe,
 *   it,
 * } from &quot;@std/testing/bdd&quot;;
 *
 * class User {
 *   static users: Map&lt;string, User&gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&quot;Age unknown&quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * const userTests = describe(&quot;User&quot;);
 *
 * it(userTests, &quot;users initially empty&quot;, () =&gt; {
 *   assertEquals(User.users.size, 0);
 * });
 *
 * it(userTests, &quot;constructor&quot;, () =&gt; {
 *   try {
 *     const user = new User(&quot;Kyle&quot;);
 *     assertEquals(user.name, &quot;Kyle&quot;);
 *     assertStrictEquals(User.users.get(&quot;Kyle&quot;), user);
 *   } finally {
 *     User.users.clear();
 *   }
 * });
 *
 * const ageTests = describe({
 *   name: &quot;age&quot;,
 *   suite: userTests,
 *   beforeEach(this: { user: User }) {
 *     this.user = new User(&quot;Kyle&quot;);
 *   },
 *   afterEach() {
 *     User.users.clear();
 *   },
 * });
 *
 * it(ageTests, &quot;getAge&quot;, function () {
 *   const { user } = this;
 *   assertThrows(() =&gt; user.getAge(), Error, &quot;Age unknown&quot;);
 *   user.age = 18;
 *   assertEquals(user.getAge(), 18);
 * });
 *
 * it(ageTests, &quot;setAge&quot;, function () {
 *   const { user } = this;
 *   user.setAge(18);
 *   assertEquals(user.getAge(), 18);
 * });
 * ```
 *
 * ### Mixed test grouping
 *
 * Both nested test grouping and flat test grouping can be used together. This can
 * be useful if you&apos;d like to create deep groupings without all the extra
 * indentation in front of each line.
 *
 * ```ts
 * import {
 *   assertEquals,
 *   assertStrictEquals,
 *   assertThrows,
 * } from &quot;@std/assert&quot;;
 * import {
 *   describe,
 *   it,
 * } from &quot;@std/testing/bdd&quot;;
 *
 * class User {
 *   static users: Map&lt;string, User&gt; = new Map();
 *   name: string;
 *   age?: number;
 *
 *   constructor(name: string) {
 *     if (User.users.has(name)) {
 *       throw new Deno.errors.AlreadyExists(`User ${name} already exists`);
 *     }
 *     this.name = name;
 *     User.users.set(name, this);
 *   }
 *
 *   getAge(): number {
 *     if (!this.age) {
 *       throw new Error(&quot;Age unknown&quot;);
 *     }
 *     return this.age;
 *   }
 *
 *   setAge(age: number) {
 *     this.age = age;
 *   }
 * }
 *
 * describe(&quot;User&quot;, () =&gt; {
 *   it(&quot;users initially empty&quot;, () =&gt; {
 *     assertEquals(User.users.size, 0);
 *   });
 *
 *   it(&quot;constructor&quot;, () =&gt; {
 *     try {
 *       const user = new User(&quot;Kyle&quot;);
 *       assertEquals(user.name, &quot;Kyle&quot;);
 *       assertStrictEquals(User.users.get(&quot;Kyle&quot;), user);
 *     } finally {
 *       User.users.clear();
 *     }
 *   });
 *
 *   const ageTests = describe({
 *     name: &quot;age&quot;,
 *     beforeEach(this: { user: User }) {
 *       this.user = new User(&quot;Kyle&quot;);
 *     },
 *     afterEach() {
 *       User.users.clear();
 *     },
 *   });
 *
 *   it(ageTests, &quot;getAge&quot;, function () {
 *     const { user } = this;
 *     assertThrows(() =&gt; user.getAge(), Error, &quot;Age unknown&quot;);
 *     user.age = 18;
 *     assertEquals(user.getAge(), 18);
 *   });
 *
 *   it(ageTests, &quot;setAge&quot;, function () {
 *     const { user } = this;
 *     user.setAge(18);
 *     assertEquals(user.getAge(), 18);
 *   });
 * });
 * ```
 *
 * @module
 */
import { getAssertionState } from &quot;@std/internal/assertion-state&quot;;
import { AssertionError } from &quot;@std/assert/assertion-error&quot;;
import {
  type DescribeDefinition,
  globalSanitizersState,
  type HookNames,
  type ItDefinition,
  type TestSuite,
  TestSuiteInternal,
} from &quot;./_test_suite.ts&quot;;
⋮----
/** The arguments for an ItFunction. */
export type ItArgs&lt;T&gt; =
  | [options: ItDefinition&lt;T&gt;]
  | [
    name: string,
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;name&quot;&gt;,
  ]
  | [
    name: string,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;]
  | [
    name: string,
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot;&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;fn&quot;&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot;&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;name&quot; | &quot;suite&quot;&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot; | &quot;suite&quot;&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;fn&quot; | &quot;suite&quot;&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    options: Omit&lt;ItDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot; | &quot;suite&quot;&gt;,
    fn: (this: T, t: Deno.TestContext) =&gt; void | Promise&lt;void&gt;,
  ];
/** Generates an ItDefinition from ItArgs. */
function itDefinition&lt;T&gt;(...args: ItArgs&lt;T&gt;): ItDefinition&lt;T&gt;
/** Registers an individual test case. */
// deno-lint-ignore deno-style-guide/naming-convention
export interface it {
  &lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
  /** Registers an individual test case with only set to true. */
  only&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
  /** Registers an individual test case with ignore set to true. */
  ignore&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
  /**
   * Registers an individual test case with ignore set to true. Alias of
   * `.ignore()`.
   */
  skip&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
}
⋮----
/** Registers an individual test case with only set to true. */
only&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
/** Registers an individual test case with ignore set to true. */
ignore&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
/**
   * Registers an individual test case with ignore set to true. Alias of
   * `.ignore()`.
   */
skip&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
⋮----
/**
 * Registers an individual test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function to implement the test case
 * @param args The test case
 */
export function it&lt;T&gt;(...args: ItArgs&lt;T&gt;)
⋮----
async fn(t)
⋮----
/**
 * Only execute this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   it.only(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/**
 * Ignore this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   it.ignore(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/** Skip this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   it.skip(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/**
 * Alias of {@linkcode it}
 *
 * Registers an individual test case.
 *
 * @example Usage
 * ```ts
 * import { test } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * test(&quot;a test case&quot;, () =&gt; {
 *   // test case
 *   assertEquals(2 + 2, 4);
 * });
 * ```
 *
 * @typeParam T The self type of the function to implement the test case
 * @param args The test case
 */
export function test&lt;T&gt;(...args: ItArgs&lt;T&gt;)
/**
 * Only execute this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, test } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   test(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   test.only(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/**
 * Ignore this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, test } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   test(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   test.ignore(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
/** Skip this test case.
 *
 * @example Usage
 * ```ts
 * import { describe, test } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   test(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 *
 *   test.skip(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test case
 */
⋮----
function addHook&lt;T&gt;(
  name: HookNames,
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/**
 * Run some shared setup before all of the tests in the group.
 * Useful for async setup in `describe` blocks. Outside them,
 * top-level initialization code should be used instead.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * beforeAll(() =&gt; {
 *  console.log(&quot;beforeAll&quot;);
 * });
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the setup behavior.
 */
export function beforeAll&lt;T&gt;(
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/**
 * Alias of {@linkcode beforeAll}
 *
 * Run some shared setup before all of the tests in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, before } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * before(() =&gt; {
 *  console.log(&quot;before&quot;);
 * });
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the setup behavior.
 */
export function before&lt;T&gt;(
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/**
 * Run some shared teardown after all of the tests in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, afterAll } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * afterAll(() =&gt; {
 *  console.log(&quot;afterAll&quot;);
 * });
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the teardown behavior.
 */
export function afterAll&lt;T&gt;(
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/**
 * Alias of {@linkcode afterAll}.
 *
 * Run some shared teardown after all of the tests in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, after } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * after(() =&gt; {
 *  console.log(&quot;after&quot;);
 * });
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the teardown behavior.
 */
export function after&lt;T&gt;(
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/**
 * Run some shared setup before each test in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeEach } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * beforeEach(() =&gt; {
 *  console.log(&quot;beforeEach&quot;);
 * });
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the shared setup behavior
 */
export function beforeEach&lt;T&gt;(
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/**
 * Run some shared teardown after each test in the suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, afterEach } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * afterEach(() =&gt; {
 *  console.log(&quot;afterEach&quot;);
 * });
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the function
 * @param fn The function to implement the shared teardown behavior
 */
export function afterEach&lt;T&gt;(
  fn: (this: T) =&gt; void | Promise&lt;void&gt;,
)
/** The arguments for a DescribeFunction. */
export type DescribeArgs&lt;T&gt; =
  | [options: DescribeDefinition&lt;T&gt;]
  | [name: string]
  | [
    name: string,
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;name&quot;&gt;,
  ]
  | [name: string, fn: () =&gt; void | undefined]
  | [fn: () =&gt; void | undefined]
  | [
    name: string,
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot;&gt;,
    fn: () =&gt; void | undefined,
  ]
  | [
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;fn&quot;&gt;,
    fn: () =&gt; void | undefined,
  ]
  | [
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot;&gt;,
    fn: () =&gt; void | undefined,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;name&quot; | &quot;suite&quot;&gt;,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
    fn: () =&gt; void | undefined,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    fn: () =&gt; void | undefined,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    name: string,
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot; | &quot;suite&quot;&gt;,
    fn: () =&gt; void | undefined,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;fn&quot; | &quot;suite&quot;&gt;,
    fn: () =&gt; void | undefined,
  ]
  | [
    suite: TestSuite&lt;T&gt;,
    options: Omit&lt;DescribeDefinition&lt;T&gt;, &quot;fn&quot; | &quot;name&quot; | &quot;suite&quot;&gt;,
    fn: () =&gt; void | undefined,
  ];
/** Generates a DescribeDefinition from DescribeArgs. */
function describeDefinition&lt;T&gt;(
  ...args: DescribeArgs&lt;T&gt;
): DescribeDefinition&lt;T&gt;
/** Registers a test suite. */
// deno-lint-ignore deno-style-guide/naming-convention
export interface describe {
  &lt;T&gt;(...args: DescribeArgs&lt;T&gt;): TestSuite&lt;T&gt;;
  /** Registers a test suite with only set to true. */
  only&lt;T&gt;(...args: DescribeArgs&lt;T&gt;): TestSuite&lt;T&gt;;
  /** Registers a test suite with ignore set to true. */
  ignore&lt;T&gt;(...args: DescribeArgs&lt;T&gt;): TestSuite&lt;T&gt;;
  /** Registers a test suite with ignore set to true. Alias of `.ignore()`. */
  skip&lt;T&gt;(...args: ItArgs&lt;T&gt;): void;
}
⋮----
/** Registers a test suite with only set to true. */
only&lt;T&gt;(...args: DescribeArgs&lt;T&gt;): TestSuite&lt;T&gt;;
/** Registers a test suite with ignore set to true. */
ignore&lt;T&gt;(...args: DescribeArgs&lt;T&gt;): TestSuite&lt;T&gt;;
/** Registers a test suite with ignore set to true. Alias of `.ignore()`. */
⋮----
/**
 * Registers a test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     // test case
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 * ```
 *
 * @typeParam T The self type of the test suite body.
 * @param args The test suite body.
 * @returns The test suite
 */
export function describe&lt;T&gt;(
  ...args: DescribeArgs&lt;T&gt;
): TestSuite&lt;T&gt;
/**
 * Only execute this test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 *
 * // Only this test suite will run
 * describe.only(&quot;example 2&quot;, () =&gt; {
 *   it(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test suite body
 */
⋮----
/**
 * Ignore the test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 *
 * describe.ignore(&quot;example 2&quot;, () =&gt; {
 *   it(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test suite body
 */
⋮----
/**
 * Skip the test suite.
 *
 * @example Usage
 * ```ts
 * import { describe, it, beforeAll } from &quot;@std/testing/bdd&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * describe(&quot;example&quot;, () =&gt; {
 *   it(&quot;should pass&quot;, () =&gt; {
 *     assertEquals(2 + 2, 4);
 *   });
 * });
 *
 * describe.skip(&quot;example 2&quot;, () =&gt; {
 *   it(&quot;should pass too&quot;, () =&gt; {
 *     assertEquals(3 + 4, 7);
 *   });
 * });
 * ```
 *
 * @param args The test suite body
 */</file><file path="testing/deno.json">{
  &quot;name&quot;: &quot;@std/testing&quot;,
  &quot;version&quot;: &quot;1.0.12&quot;,
  &quot;exports&quot;: {
    &quot;./bdd&quot;: &quot;./bdd.ts&quot;,
    &quot;./mock&quot;: &quot;./mock.ts&quot;,
    &quot;./snapshot&quot;: &quot;./snapshot.ts&quot;,
    &quot;./time&quot;: &quot;./time.ts&quot;,
    &quot;./types&quot;: &quot;./types.ts&quot;,
    &quot;./unstable-bdd&quot;: &quot;./unstable_bdd.ts&quot;,
    &quot;./unstable-snapshot&quot;: &quot;./unstable_snapshot.ts&quot;,
    &quot;./unstable-stub&quot;: &quot;./unstable_stub.ts&quot;,
    &quot;./unstable-types&quot;: &quot;./unstable_types.ts&quot;
  }
}</file><file path="testing/mock_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { delay } from &quot;@std/async/delay&quot;;
import {
  assertEquals,
  AssertionError,
  assertNotEquals,
  assertRejects,
  assertThrows,
} from &quot;@std/assert&quot;;
import {
  assertSpyCall,
  assertSpyCallArg,
  assertSpyCallArgs,
  assertSpyCallAsync,
  assertSpyCalls,
  type ExpectedSpyCall,
  type MethodSpy,
  MockError,
  mockSession,
  mockSessionAsync,
  resolvesNext,
  restore,
  returnsArg,
  returnsArgs,
  returnsNext,
  returnsThis,
  type Spy,
  spy,
  type Stub,
  stub,
} from &quot;./mock.ts&quot;;
import { Point, type PointWithExtra, stringifyPoint } from &quot;./_test_utils.ts&quot;;
⋮----
// Check if the returned type is correct:
⋮----
// @ts-expect-error Test if passing incorrect argument types causes an error
⋮----
// @ts-expect-error Test if passing incorrect return type causes an error
⋮----
// Calling assertSpyCall with the correct types should not cause any type errors:
⋮----
override action()
⋮----
class Foo
⋮----
constructor()
⋮----
fn()
⋮----
const obj =
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// This doesn&apos;t test any runtime code, only if the TypeScript types are correct.
⋮----
// @ts-expect-error Stubbing with incorrect argument types should cause a type error
⋮----
// @ts-expect-error Stubbing with an incorrect return type should cause a type error
⋮----
// Stubbing without argument types infers them from the real function
⋮----
// `toExponential()` only exists on `number`, so this will error if _x is not a number
⋮----
// `toLowerCase()` only exists on `string`, so this will error if _y is not a string
⋮----
// Stubbing with returnsNext() should not give any type errors
⋮----
// Stubbing without argument types should not cause any type errors:
⋮----
// Check if the returned type is correct:
⋮----
// @ts-expect-error Test if passing incorrect argument types causes an error
⋮----
// @ts-expect-error Test if passing incorrect return type causes an error
⋮----
// Calling assertSpyCall with the correct types should not cause any type errors
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function assertRestored(expected: boolean[])
⋮----
class ExampleError extends Error
class OtherError extends Error</file><file path="testing/mock.ts">// Copyright 2018-2025 the Deno authors. MIT license.
/** A mocking and spying library.
 *
 * Test spies are function stand-ins that are used to assert if a function&apos;s
 * internal behavior matches expectations. Test spies on methods keep the original
 * behavior but allow you to test how the method is called and what it returns.
 * Test stubs are an extension of test spies that also replaces the original
 * methods behavior.
 *
 * ## Spying
 *
 * Say we have two functions, `square` and `multiply`, if we want to assert that
 * the `multiply` function is called during execution of the `square` function we
 * need a way to spy on the `multiply` function. There are a few ways to achieve
 * this with Spies, one is to have the `square` function take the `multiply`
 * multiply as a parameter.
 *
 * This way, we can call `square(multiply, value)` in the application code or wrap
 * a spy function around the `multiply` function and call
 * `square(multiplySpy, value)` in the testing code.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * function multiply(a: number, b: number): number {
 *   return a * b;
 * }
 *
 * function square(
 *   multiplyFn: (a: number, b: number) =&gt; number,
 *   value: number,
 * ): number {
 *   return multiplyFn(value, value);
 * }
 *
 * Deno.test(&quot;square calls multiply and returns results&quot;, () =&gt; {
 *   const multiplySpy = spy(multiply);
 *
 *   assertEquals(square(multiplySpy, 5), 25);
 *
 *   // asserts that multiplySpy was called at least once and details about the first call.
 *   assertSpyCall(multiplySpy, 0, {
 *     args: [5, 5],
 *     returned: 25,
 *   });
 *
 *   // asserts that multiplySpy was only called once.
 *   assertSpyCalls(multiplySpy, 1);
 * });
 * ```
 *
 * If you prefer not adding additional parameters for testing purposes only, you
 * can use spy to wrap a method on an object instead. In the following example, the
 * exported `_internals` object has the `multiply` function we want to call as a
 * method and the `square` function calls `_internals.multiply` instead of
 * `multiply`.
 *
 * This way, we can call `square(value)` in both the application code and testing
 * code. Then spy on the `multiply` method on the `_internals` object in the
 * testing code to be able to spy on how the `square` function calls the `multiply`
 * function.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * function multiply(a: number, b: number): number {
 *   return a * b;
 * }
 *
 * function square(value: number): number {
 *   return _internals.multiply(value, value);
 * }
 *
 * const _internals = { multiply };
 *
 * Deno.test(&quot;square calls multiply and returns results&quot;, () =&gt; {
 *   const multiplySpy = spy(_internals, &quot;multiply&quot;);
 *
 *   try {
 *     assertEquals(square(5), 25);
 *   } finally {
 *     // unwraps the multiply method on the _internals object
 *     multiplySpy.restore();
 *   }
 *
 *   // asserts that multiplySpy was called at least once and details about the first call.
 *   assertSpyCall(multiplySpy, 0, {
 *     args: [5, 5],
 *     returned: 25,
 *   });
 *
 *   // asserts that multiplySpy was only called once.
 *   assertSpyCalls(multiplySpy, 1);
 * });
 * ```
 *
 * One difference you may have noticed between these two examples is that in the
 * second we call the `restore` method on `multiplySpy` function. That is needed to
 * remove the spy wrapper from the `_internals` object&apos;s `multiply` method. The
 * `restore` method is called in a finally block to ensure that it is restored
 * whether or not the assertion in the try block is successful. The `restore`
 * method didn&apos;t need to be called in the first example because the `multiply`
 * function was not modified in any way like the `_internals` object was in the
 * second example.
 *
 * Method spys are disposable, meaning that you can have them automatically restore
 * themselves with the `using` keyword. Using this approach is cleaner because you
 * do not need to wrap your assertions in a try statement to ensure you restore the
 * methods before the tests finish.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * function multiply(a: number, b: number): number {
 *   return a * b;
 * }
 *
 * function square(value: number): number {
 *   return _internals.multiply(value, value);
 * }
 *
 * const _internals = { multiply };
 *
 * Deno.test(&quot;square calls multiply and returns results&quot;, () =&gt; {
 *   using multiplySpy = spy(_internals, &quot;multiply&quot;);
 *
 *   assertEquals(square(5), 25);
 *
 *   // asserts that multiplySpy was called at least once and details about the first call.
 *   assertSpyCall(multiplySpy, 0, {
 *     args: [5, 5],
 *     returned: 25,
 *   });
 *
 *   // asserts that multiplySpy was only called once.
 *   assertSpyCalls(multiplySpy, 1);
 * });
 * ```
 *
 * ## Stubbing
 *
 * Say we have two functions, `randomMultiple` and `randomInt`, if we want to
 * assert that `randomInt` is called during execution of `randomMultiple` we need a
 * way to spy on the `randomInt` function. That could be done with either of the
 * spying techniques previously mentioned. To be able to verify that the
 * `randomMultiple` function returns the value we expect it to for what `randomInt`
 * returns, the easiest way would be to replace the `randomInt` function&apos;s behavior
 * with more predictable behavior.
 *
 * You could use the first spying technique to do that but that would require
 * adding a `randomInt` parameter to the `randomMultiple` function.
 *
 * You could also use the second spying technique to do that, but your assertions
 * would not be as predictable due to the `randomInt` function returning random
 * values.
 *
 * Say we want to verify it returns correct values for both negative and positive
 * random integers. We could easily do that with stubbing. The below example is
 * similar to the second spying technique example but instead of passing the call
 * through to the original `randomInt` function, we are going to replace
 * `randomInt` with a function that returns pre-defined values.
 *
 * The mock module includes some helper functions to make creating common stubs
 * easy. The `returnsNext` function takes an array of values we want it to return
 * on consecutive calls.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   returnsNext,
 *   stub,
 * } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * function randomInt(lowerBound: number, upperBound: number): number {
 *   return lowerBound + Math.floor(Math.random() * (upperBound - lowerBound));
 * }
 *
 * function randomMultiple(value: number): number {
 *   return value * _internals.randomInt(-10, 10);
 * }
 *
 * const _internals = { randomInt };
 *
 * Deno.test(&quot;randomMultiple uses randomInt to generate random multiples between -10 and 10 times the value&quot;, () =&gt; {
 *   const randomIntStub = stub(_internals, &quot;randomInt&quot;, returnsNext([-3, 3]));
 *
 *   try {
 *     assertEquals(randomMultiple(5), -15);
 *     assertEquals(randomMultiple(5), 15);
 *   } finally {
 *     // unwraps the randomInt method on the _internals object
 *     randomIntStub.restore();
 *   }
 *
 *   // asserts that randomIntStub was called at least once and details about the first call.
 *   assertSpyCall(randomIntStub, 0, {
 *     args: [-10, 10],
 *     returned: -3,
 *   });
 *   // asserts that randomIntStub was called at least twice and details about the second call.
 *   assertSpyCall(randomIntStub, 1, {
 *     args: [-10, 10],
 *     returned: 3,
 *   });
 *
 *   // asserts that randomIntStub was only called twice.
 *   assertSpyCalls(randomIntStub, 2);
 * });
 * ```
 *
 * Like method spys, stubs are disposable, meaning that you can have them automatically
 * restore themselves with the `using` keyword. Using this approach is cleaner because
 * you do not need to wrap your assertions in a try statement to ensure you restore the
 * methods before the tests finish.
 *
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   returnsNext,
 *   stub,
 * } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * function randomInt(lowerBound: number, upperBound: number): number {
 *   return lowerBound + Math.floor(Math.random() * (upperBound - lowerBound));
 * }
 *
 * function randomMultiple(value: number): number {
 *   return value * _internals.randomInt(-10, 10);
 * }
 *
 * const _internals = { randomInt };
 *
 * Deno.test(&quot;randomMultiple uses randomInt to generate random multiples between -10 and 10 times the value&quot;, () =&gt; {
 *   using randomIntStub = stub(_internals, &quot;randomInt&quot;, returnsNext([-3, 3]));
 *
 *   assertEquals(randomMultiple(5), -15);
 *   assertEquals(randomMultiple(5), 15);
 *
 *   // asserts that randomIntStub was called at least once and details about the first call.
 *   assertSpyCall(randomIntStub, 0, {
 *     args: [-10, 10],
 *     returned: -3,
 *   });
 *   // asserts that randomIntStub was called at least twice and details about the second call.
 *   assertSpyCall(randomIntStub, 1, {
 *     args: [-10, 10],
 *     returned: 3,
 *   });
 *
 *   // asserts that randomIntStub was only called twice.
 *   assertSpyCalls(randomIntStub, 2);
 * });
 * ```
 *
 * ## Faking time
 *
 * Say we have a function that has time based behavior that we would like to test.
 * With real time, that could cause tests to take much longer than they should. If
 * you fake time, you could simulate how your function would behave over time
 * starting from any point in time. Below is an example where we want to test that
 * the callback is called every second.
 *
 * With `FakeTime` we can do that. When the `FakeTime` instance is created, it
 * splits from real time. The `Date`, `setTimeout`, `clearTimeout`, `setInterval`
 * and `clearInterval` globals are replaced with versions that use the fake time
 * until real time is restored. You can control how time ticks forward with the
 * `tick` method on the `FakeTime` instance.
 *
 * ```ts
 * import {
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 * import { FakeTime } from &quot;@std/testing/time&quot;;
 *
 * function secondInterval(cb: () =&gt; void): number {
 *   return setInterval(cb, 1000);
 * }
 *
 * Deno.test(&quot;secondInterval calls callback every second and stops after being cleared&quot;, () =&gt; {
 *   using time = new FakeTime();
 *
 *   const cb = spy();
 *   const intervalId = secondInterval(cb);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 1);
 *   time.tick(3500);
 *   assertSpyCalls(cb, 4);
 *
 *   clearInterval(intervalId);
 *   time.tick(1000);
 *   assertSpyCalls(cb, 4);
 * });
 * ```
 *
 * @module
 */
import { assertEquals } from &quot;@std/assert/equals&quot;;
import { assertIsError } from &quot;@std/assert/is-error&quot;;
import { assertRejects } from &quot;@std/assert/rejects&quot;;
import { AssertionError } from &quot;@std/assert/assertion-error&quot;;
import {
  isSpy,
  registerMock,
  sessions,
  unregisterMock,
} from &quot;./_mock_utils.ts&quot;;
/**
 * An error related to spying on a function or instance method.
 *
 * @example Usage
 * ```ts
 * import { MockError, spy } from &quot;@std/testing/mock&quot;;
 * import { assertThrows } from &quot;@std/assert&quot;;
 *
 * assertThrows(() =&gt; {
 *   spy({} as any, &quot;no-such-method&quot;);
 * }, MockError);
 * ```
 */
export class MockError extends Error
⋮----
/**
   * Construct MockError
   *
   * @param message The error message.
   */
constructor(message: string)
⋮----
/** Call information recorded by a spy. */
export interface SpyCall&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; {
  /** Arguments passed to a function when called. */
  args: Args;
  /** The value that was returned by a function. */
  returned?: Return;
  /** The error value that was thrown by a function. */
  error?: Error;
  /** The instance that a method was called on. */
  self?: Self;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Arguments passed to a function when called. */
⋮----
/** The value that was returned by a function. */
⋮----
/** The error value that was thrown by a function. */
⋮----
/** The instance that a method was called on. */
⋮----
/** A function or instance method wrapper that records all calls made to it. */
export interface Spy&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; {
  (this: Self, ...args: Args): Return;
  /** The function that is being spied on. */
  original: (this: Self, ...args: Args) =&gt; Return;
  /** Information about calls made to the function or instance method. */
  calls: SpyCall&lt;Self, Args, Return&gt;[];
  /** Whether or not the original instance method has been restored. */
  restored: boolean;
  /** If spying on an instance method, this restores the original instance method. */
  restore(): void;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The function that is being spied on. */
⋮----
/** Information about calls made to the function or instance method. */
⋮----
/** Whether or not the original instance method has been restored. */
⋮----
/** If spying on an instance method, this restores the original instance method. */
restore(): void;
⋮----
/** An instance method wrapper that records all calls made to it. */
export interface MethodSpy&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; extends Spy&lt;Self, Args, Return&gt;, Disposable {}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Wraps a function with a Spy. */
function functionSpy&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(func?: (this: Self, ...args: Args) =&gt; Return): Spy&lt;Self, Args, Return&gt;
/**
 * Creates a session that tracks all mocks created before it&apos;s restored.
 * If a callback is provided, it restores all mocks created within it.
 *
 * @example Usage
 * ```ts
 * import { mockSession, restore, stub } from &quot;@std/testing/mock&quot;;
 * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 * const id = mockSession();
 *
 * stub(globalThis, &quot;setTimeout&quot;);
 *
 * assertNotEquals(globalThis.setTimeout, setTimeout);
 *
 * restore(id);
 *
 * assertEquals(globalThis.setTimeout, setTimeout);
 * ```
 *
 * @returns The id of the created session.
 */
export function mockSession(): number;
/**
 * Creates a session that tracks all mocks created before it&apos;s restored.
 * If a callback is provided, it restores all mocks created within it.
 *
 * @example Usage
 * ```ts
 * import { mockSession, restore, stub } from &quot;@std/testing/mock&quot;;
 * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 * const session = mockSession(() =&gt; {
 *   stub(globalThis, &quot;setTimeout&quot;);
 *   assertNotEquals(globalThis.setTimeout, setTimeout);
 * });
 *
 * session();
 *
 * assertEquals(globalThis.setTimeout, setTimeout); // stub is restored
 * ```
 *
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @param func The function to be used for the created session.
 * @returns The function to execute the session.
 */
export function mockSession&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  func: (this: Self, ...args: Args) =&gt; Return,
): (this: Self, ...args: Args)
export function mockSession&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  func?: (this: Self, ...args: Args) =&gt; Return,
): number | ((this: Self, ...args: Args) =&gt; Return)
/**
 * Creates an async session that tracks all mocks created before the promise resolves.
 *
 * @example Usage
 * ```ts
 * import { mockSessionAsync, restore, stub } from &quot;@std/testing/mock&quot;;
 * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 * const session = mockSessionAsync(async () =&gt; {
 *   stub(globalThis, &quot;setTimeout&quot;);
 *   assertNotEquals(globalThis.setTimeout, setTimeout);
 * });
 *
 * await session();
 *
 * assertEquals(globalThis.setTimeout, setTimeout); // stub is restored
 * ```
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @param func The function.
 * @returns The return value of the function.
 */
export function mockSessionAsync&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  func: (this: Self, ...args: Args) =&gt; Promise&lt;Return&gt;,
): (this: Self, ...args: Args) =&gt; Promise&lt;Return&gt;
/**
 * Restores all mocks registered in the current session that have not already been restored.
 * If an id is provided, it will restore all mocks registered in the session associed with that id that have not already been restored.
 *
 * @example Usage
 * ```ts
 * import { mockSession, restore, stub } from &quot;@std/testing/mock&quot;;
 * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;;
 *
 * const setTimeout = globalThis.setTimeout;
 *
 * stub(globalThis, &quot;setTimeout&quot;);
 *
 * assertNotEquals(globalThis.setTimeout, setTimeout);
 *
 * restore();
 *
 * assertEquals(globalThis.setTimeout, setTimeout);
 * ```
 *
 * @param id The id of the session to restore. If not provided, all mocks registered in the current session are restored.
 */
export function restore(id?: number)
/** Wraps an instance method with a Spy. */
function methodSpy&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(self: Self, property: keyof Self): MethodSpy&lt;Self, Args, Return&gt;
/** A constructor wrapper that records all calls made to it. */
export interface ConstructorSpy&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&gt; {
  /** Construct an instance. */
  new (...args: Args): Self;
  /** The function that is being spied on. */
  original: new (...args: Args) =&gt; Self;
  /** Information about calls made to the function or instance method. */
  calls: SpyCall&lt;Self, Args, Self&gt;[];
  /** Whether or not the original instance method has been restored. */
  restored: boolean;
  /** If spying on an instance method, this restores the original instance method. */
  restore(): void;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Construct an instance. */
⋮----
/** The function that is being spied on. */
⋮----
/** Information about calls made to the function or instance method. */
⋮----
/** Whether or not the original instance method has been restored. */
⋮----
/** If spying on an instance method, this restores the original instance method. */
⋮----
/** Wraps a constructor with a Spy. */
function constructorSpy&lt;
  Self,
  Args extends unknown[],
&gt;(
  constructor: new (...args: Args) =&gt; Self,
): ConstructorSpy&lt;Self, Args&gt;
⋮----
// @ts-ignore TS2509: Can&apos;t know the type of `original` statically.
⋮----
// deno-lint-ignore constructor-super
constructor(...args: Args)
⋮----
static restore()
⋮----
/**
 * Utility for extracting the arguments type from a property
 *
 * @internal
 */
export type GetParametersFromProp&lt;
  Self,
  Prop extends keyof Self,
&gt; = Self[Prop] extends (...args: infer Args) =&gt; unknown ? Args
  : unknown[];
/**
 * Utility for extracting the return type from a property
 *
 * @internal
 */
export type GetReturnFromProp&lt;
  Self,
  Prop extends keyof Self,
&gt; // deno-lint-ignore no-explicit-any
 = Self[Prop] extends (...args: any[]) =&gt; infer Return ? Return
  : unknown;
⋮----
&gt; // deno-lint-ignore no-explicit-any
⋮----
/** SpyLink object type. */
export type SpyLike&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; = Spy&lt;Self, Args, Return&gt; | ConstructorSpy&lt;Self, Args&gt;;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Creates a spy function.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy();
 *
 * func();
 * func(1);
 * func(2, 3);
 *
 * assertSpyCalls(func, 3);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(func, 0, { args: [] });
 * assertSpyCall(func, 1, { args: [1] });
 * assertSpyCall(func, 2, { args: [2, 3] });
 * ```
 *
 * @typeParam Self The self type of the function.
 * @typeParam Args The arguments type of the function.
 * @typeParam Return The return type of the function.
 * @returns The spy function.
 */
export function spy&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  Return = undefined,
&gt;(): Spy&lt;Self, Args, Return&gt;;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Create a spy function with the given implementation.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((a: number, b: number) =&gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * assertSpyCalls(func, 2);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(func, 0, { args: [3, 4], returned: 7 });
 * assertSpyCall(func, 1, { args: [5, 6], returned: 11 });
 * ```
 *
 * @typeParam Self The self type of the function to wrap
 * @typeParam Args The arguments type of the function to wrap
 * @typeParam Return The return type of the function to wrap
 * @param func The function to wrap
 * @returns The wrapped function.
 */
export function spy&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(func: (this: Self, ...args: Args)
/**
 * Create a spy constructor.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 *
 * class Foo {
 *   constructor(value: string) {}
 * };
 *
 * const Constructor = spy(Foo);
 *
 * new Constructor(&quot;foo&quot;);
 * new Constructor(&quot;bar&quot;);
 *
 * assertSpyCalls(Constructor, 2);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(Constructor, 0, { args: [&quot;foo&quot;] });
 * assertSpyCall(Constructor, 1, { args: [&quot;bar&quot;] });
 * ```
 *
 * @typeParam Self The type of the instance of the class.
 * @typeParam Args The arguments type of the constructor
 * @param constructor The constructor to spy.
 * @returns The wrapped constructor.
 */
export function spy&lt;
  Self,
  Args extends unknown[],
&gt;(
  constructor: new (...args: Args) =&gt; Self,
): ConstructorSpy&lt;Self, Args&gt;;
/**
 * Wraps a instance method with a Spy.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCall,
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 *
 * const obj = {
 *   method(a: number, b: number): number {
 *     return a + b;
 *   },
 * };
 *
 * const methodSpy = spy(obj, &quot;method&quot;);
 *
 * obj.method(1, 2);
 * obj.method(3, 4);
 *
 * assertSpyCalls(methodSpy, 2);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(methodSpy, 0, { args: [1, 2], returned: 3 });
 * assertSpyCall(methodSpy, 1, { args: [3, 4], returned: 7 });
 * ```
 *
 * @typeParam Self The type of the instance to spy the method of.
 * @typeParam Prop The property to spy.
 * @param self The instance to spy.
 * @param property The property of the method to spy.
 * @returns The spy function.
 */
⋮----
export function spy&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  funcOrConstOrSelf?:
    | ((this: Self, ...args: Args) =&gt; Return)
    | (new (...args: Args) =&gt; Self)
    | Self,
  property?: keyof Self,
): SpyLike&lt;Self, Args, Return&gt;
/** An instance method replacement that records all calls made to it. */
export interface Stub&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; extends MethodSpy&lt;Self, Args, Return&gt; {
  /** The function that is used instead of the original. */
  fake: (this: Self, ...args: Args) =&gt; Return;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The function that is used instead of the original. */
⋮----
/**
 * Replaces an instance method with a Stub with empty implementation.
 *
 * @example Usage
 * ```ts
 * import { stub, assertSpyCalls } from &quot;@std/testing/mock&quot;;
 *
 * const obj = {
 *   method() {
 *     // some inconventient feature for testing
 *   },
 * };
 *
 * const methodStub = stub(obj, &quot;method&quot;);
 *
 * for (const _ of Array(5)) {
 *   obj.method();
 * }
 *
 * assertSpyCalls(methodStub, 5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @returns The stub function which replaced the original.
 */
export function stub&lt;
  Self,
  Prop extends keyof Self,
&gt;(
  self: Self,
  property: Prop,
): Stub&lt;Self, GetParametersFromProp&lt;Self, Prop&gt;, GetReturnFromProp&lt;Self, Prop&gt;&gt;;
/**
 * Replaces an instance method with a Stub with the given implementation.
 *
 * @example Usage
 * ```ts
 * import { stub } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * const obj = {
 *   method(): number {
 *     return Math.random();
 *   },
 * };
 *
 * const methodStub = stub(obj, &quot;method&quot;, () =&gt; 0.5);
 *
 * assertEquals(obj.method(), 0.5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @param func The fake implementation of the function.
 * @returns The stub function which replaced the original.
 */
export function stub&lt;
  Self,
  Prop extends keyof Self,
&gt;(
  self: Self,
  property: Prop,
  func: (
    this: Self,
    ...args: GetParametersFromProp&lt;Self, Prop&gt;
  ) =&gt; GetReturnFromProp&lt;Self, Prop&gt;,
): Stub&lt;Self, GetParametersFromProp&lt;Self, Prop&gt;, GetReturnFromProp&lt;Self, Prop&gt;&gt;;
export function stub&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  self: Self,
  property: keyof Self,
  func?: (this: Self, ...args: Args) =&gt; Return,
): Stub&lt;Self, Args, Return&gt;
/**
 * Asserts that a spy is called as much as expected and no more.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCalls, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy();
 *
 * func();
 * func();
 *
 * assertSpyCalls(func, 2);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @param spy The spy to check
 * @param expectedCalls The number of the expected calls.
 */
export function assertSpyCalls&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  expectedCalls: number,
)
/** Call information recorded by a spy. */
export interface ExpectedSpyCall&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; {
  /** Arguments passed to a function when called. */
  args?: [...Args, ...unknown[]];
  /** The instance that a method was called on. */
  self?: Self;
  /**
   * The value that was returned by a function.
   * If you expect a promise to reject, expect error instead.
   */
  returned?: Return;
  /** The expected thrown error. */
  error?: {
    /** The class for the error that was thrown by a function. */
    // deno-lint-ignore no-explicit-any
    Class?: new (...args: any[]) =&gt; Error;
    /** Part of the message for the error that was thrown by a function. */
    msgIncludes?: string;
  };
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** Arguments passed to a function when called. */
⋮----
/** The instance that a method was called on. */
⋮----
/**
   * The value that was returned by a function.
   * If you expect a promise to reject, expect error instead.
   */
⋮----
/** The expected thrown error. */
⋮----
/** The class for the error that was thrown by a function. */
// deno-lint-ignore no-explicit-any
⋮----
/** Part of the message for the error that was thrown by a function. */
⋮----
function getSpyCall&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
): SpyCall
/**
 * Asserts that a spy is called as expected.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCall, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((a: number, b: number) =&gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * // asserts each call made to the spy function.
 * assertSpyCall(func, 0, { args: [3, 4], returned: 7 });
 * assertSpyCall(func, 1, { args: [5, 6], returned: 11 });
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @param spy The spy to check
 * @param callIndex The index of the call to check
 * @param expected The expected spy call.
 */
export function assertSpyCall&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
  expected?: ExpectedSpyCall&lt;Self, Args, Return&gt;,
)
/**
 * Asserts that an async spy is called as expected.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallAsync, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((a: number, b: number) =&gt; new Promise((resolve) =&gt; {
 *   setTimeout(() =&gt; resolve(a + b), 100)
 * }));
 *
 * await func(3, 4);
 * await func(5, 6);
 *
 * // asserts each call made to the spy function.
 * await assertSpyCallAsync(func, 0, { args: [3, 4], returned: 7 });
 * await assertSpyCallAsync(func, 1, { args: [5, 6], returned: 11 });
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @param spy The spy to check
 * @param callIndex The index of the call to check
 * @param expected The expected spy call.
 */
export async function assertSpyCallAsync&lt;
  Self,
  Args extends unknown[],
  Return,
&gt;(
  spy: SpyLike&lt;Self, Args, Promise&lt;Return&gt;&gt;,
  callIndex: number,
  expected?: ExpectedSpyCall&lt;Self, Args, Promise&lt;Return&gt; | Return&gt;,
)
/**
 * Asserts that a spy is called with a specific arg as expected.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArg, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((a: number, b: number) =&gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * // asserts each call made to the spy function.
 * assertSpyCallArg(func, 0, 0, 3);
 * assertSpyCallArg(func, 0, 1, 4);
 * assertSpyCallArg(func, 1, 0, 5);
 * assertSpyCallArg(func, 1, 1, 6);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArg The expected type of the argument for the spy to be called.
 * @param spy The spy to check.
 * @param callIndex The index of the call to check.
 * @param argIndex The index of the arguments to check.
 * @param expected The expected argument.
 * @returns The actual argument.
 */
export function assertSpyCallArg&lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArg,
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
  argIndex: number,
  expected: ExpectedArg,
): ExpectedArg
/**
 * Asserts that an spy is called with a specific range of args as expected.
 * If a start and end index is not provided, the expected will be compared against all args.
 * If a start is provided without an end index, the expected will be compared against all args from the start index to the end.
 * The end index is not included in the range of args that are compared.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArgs, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((a: number, b: number) =&gt; a + b);
 *
 * func(3, 4);
 * func(5, 6);
 *
 * // asserts each call made to the spy function.
 * assertSpyCallArgs(func, 0, [3, 4]);
 * assertSpyCallArgs(func, 1, [5, 6]);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArgs The expected type of the arguments for the spy to be called.
 * @param spy The spy to check.
 * @param callIndex The index of the call to check.
 * @param expected The expected arguments.
 * @returns The actual arguments.
 */
export function assertSpyCallArgs&lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArgs extends unknown[],
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
  expected: ExpectedArgs,
): ExpectedArgs;
/**
 * Asserts that an spy is called with a specific range of args as expected.
 * If a start and end index is not provided, the expected will be compared against all args.
 * If a start is provided without an end index, the expected will be compared against all args from the start index to the end.
 * The end index is not included in the range of args that are compared.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArgs, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((...args) =&gt; {});
 *
 * func(0, 1, 2, 3, 4, 5);
 *
 * assertSpyCallArgs(func, 0, 3, [3, 4, 5]);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArgs The expected type of the arguments for the spy to be called.
 * @param spy The spy to check.
 * @param callIndex The index of the call to check.
 * @param argsStart The start index of the arguments to check. If not specified, it checks the arguments from the beignning.
 * @param expected The expected arguments.
 * @returns The actual arguments.
 */
export function assertSpyCallArgs&lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArgs extends unknown[],
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
  argsStart: number,
  expected: ExpectedArgs,
): ExpectedArgs;
/**
 * Asserts that an spy is called with a specific range of args as expected.
 * If a start and end index is not provided, the expected will be compared against all args.
 * If a start is provided without an end index, the expected will be compared against all args from the start index to the end.
 * The end index is not included in the range of args that are compared.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCallArgs, spy } from &quot;@std/testing/mock&quot;;
 *
 * const func = spy((...args) =&gt; {});
 *
 * func(0, 1, 2, 3, 4, 5);
 *
 * assertSpyCallArgs(func, 0, 3, 4, [3]);
 * ```
 *
 * @typeParam Self The self type of the spy function.
 * @typeParam Args The arguments type of the spy function.
 * @typeParam Return The return type of the spy function.
 * @typeParam ExpectedArgs The expected type of the arguments for the spy to be called.
 * @param spy The spy to check
 * @param callIndex The index of the call to check
 * @param argsStart The start index of the arguments to check. If not specified, it checks the arguments from the beignning.
 * @param argsEnd The end index of the arguments to check. If not specified, it checks the arguments until the end.
 * @param expected The expected arguments.
 * @returns The actual arguments
 */
export function assertSpyCallArgs&lt;
  Self,
  Args extends unknown[],
  Return,
  ExpectedArgs extends unknown[],
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
  argsStart: number,
  argsEnd: number,
  expected: ExpectedArgs,
): ExpectedArgs;
export function assertSpyCallArgs&lt;
  ExpectedArgs extends unknown[],
  Args extends unknown[],
  Return,
  Self,
&gt;(
  spy: SpyLike&lt;Self, Args, Return&gt;,
  callIndex: number,
  argsStart?: number | ExpectedArgs,
  argsEnd?: number | ExpectedArgs,
  expected?: ExpectedArgs,
): ExpectedArgs
/**
 * Creates a function that returns the instance the method was called on.
 *
 * @example Usage
 * ```ts
 * import { returnsThis } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * const func = returnsThis();
 * const obj = { func };
 * assertEquals(obj.func(), obj);
 * ```
 *
 * @typeParam Self The self type of the returned function.
 * @typeParam Args The arguments type of the returned function.
 * @returns A function that returns the instance the method was called on.
 */
export function returnsThis&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&gt;(): (this: Self, ...args: Args) =&gt; Self
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that returns one of its arguments.
 *
 * @example Usage
 * ```ts
 * import { returnsArg } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * const func = returnsArg(1);
 * assertEquals(func(1, 2, 3), 2);
 * ```
 *
 * @typeParam Arg The type of returned argument.
 * @typeParam Self The self type of the returned function.
 * @param idx The index of the arguments to use.
 * @returns A function that returns one of its arguments.
 */
export function returnsArg&lt;
  Arg,
  // deno-lint-ignore no-explicit-any
  Self = any,
&gt;(
  idx: number,
): (this: Self, ...args: Arg[]) =&gt; Arg | undefined
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that returns its arguments or a subset of them. If end is specified, it will return arguments up to but not including the end.
 *
 * @example Usage
 * ```ts
 * import { returnsArgs } from &quot;@std/testing/mock&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * const func = returnsArgs();
 * assertEquals(func(1, 2, 3), [1, 2, 3]);
 * ```
 *
 * @typeParam Args The arguments type of the returned function
 * @typeParam Self The self type of the returned function
 * @param start The start index of the arguments to return. Default is 0.
 * @param end The end index of the arguments to return.
 * @returns A function that returns its arguments or a subset of them.
 */
export function returnsArgs&lt;
  Args extends unknown[],
  // deno-lint-ignore no-explicit-any
  Self = any,
&gt;(
  start = 0,
  end?: number,
): (this: Self, ...args: Args) =&gt; Args
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that returns the iterable values. Any iterable values that are errors will be thrown.
 *
 * @example Usage
 * ```ts
 * import { returnsNext } from &quot;@std/testing/mock&quot;;
 * import { assertEquals, assertThrows } from &quot;@std/assert&quot;;
 *
 * const func = returnsNext([1, 2, new Error(&quot;foo&quot;), 3]);
 * assertEquals(func(), 1);
 * assertEquals(func(), 2);
 * assertThrows(() =&gt; func(), Error, &quot;foo&quot;);
 * assertEquals(func(), 3);
 * ```
 *
 * @typeParam Return The type of each item of the iterable
 * @typeParam Self The self type of the returned function
 * @typeParam Args The arguments type of the returned function
 * @param values The iterable values
 * @return A function that returns the iterable values
 */
export function returnsNext&lt;
  Return,
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&gt;(
  values: Iterable&lt;Return | Error&gt;,
): (this: Self, ...args: Args) =&gt; Return
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
 * Creates a function that resolves the awaited iterable values. Any awaited iterable values that are errors will be thrown.
 *
 * @example Usage
 * ```ts
 * import { resolvesNext } from &quot;@std/testing/mock&quot;;
 * import { assertEquals, assertRejects } from &quot;@std/assert&quot;;
 *
 * const func = resolvesNext([1, 2, new Error(&quot;foo&quot;), 3]);
 * assertEquals(await func(), 1);
 * assertEquals(await func(), 2);
 * assertRejects(() =&gt; func(), Error, &quot;foo&quot;);
 * assertEquals(await func(), 3);
 * ```
 *
 * @typeParam Return The type of each item of the iterable
 * @typeParam Self The self type of the returned function
 * @typeParam Args The type of arguments of the returned function
 * @param iterable The iterable to use
 * @returns A function that resolves the awaited iterable values
 */
export function resolvesNext&lt;
  Return,
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
&gt;(
  iterable:
    | Iterable&lt;Return | Error | Promise&lt;Return | Error&gt;&gt;
    | AsyncIterable&lt;Return | Error | Promise&lt;Return | Error&gt;&gt;,
): (this: Self, ...args: Args) =&gt; Promise&lt;Return&gt;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any</file><file path="testing/README.md">This package provides utilities for testing.

- [BDD style testing](https://jsr.io/@std/testing/doc/bdd/~)
- [Test doubles (mocking)](https://jsr.io/@std/testing/doc/mock/~)
- [Faking time and timers](https://jsr.io/@std/testing/doc/time/~)
- [Snapshot testing](https://jsr.io/@std/testing/doc/snapshot/~)
- [Type assertions](https://jsr.io/@std/testing/doc/types/~)

```ts
import { assertSpyCalls, spy } from &quot;@std/testing/mock&quot;;
import { FakeTime } from &quot;@std/testing/time&quot;;

function secondInterval(cb: () =&gt; void): number {
  return setInterval(cb, 1000);
}

Deno.test(&quot;secondInterval calls callback every second and stops after being cleared&quot;, () =&gt; {
  using time = new FakeTime();

  const cb = spy();
  const intervalId = secondInterval(cb);
  assertSpyCalls(cb, 0);
  time.tick(500);
  assertSpyCalls(cb, 0);
  time.tick(500);
  assertSpyCalls(cb, 1);
  time.tick(3500);
  assertSpyCalls(cb, 4);

  clearInterval(intervalId);
  time.tick(1000);
  assertSpyCalls(cb, 4);
});
```</file><file path="testing/snapshot_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { stripAnsiCode } from &quot;@std/fmt/colors&quot;;
import { dirname, fromFileUrl, join, toFileUrl } from &quot;@std/path&quot;;
import {
  assert,
  assertInstanceOf,
  AssertionError,
  assertRejects,
  assertStringIncludes,
  fail,
} from &quot;@std/assert&quot;;
import { assertSnapshot, createAssertSnapshot, serialize } from &quot;./snapshot.ts&quot;;
import { ensureDir } from &quot;../fs/ensure_dir.ts&quot;;
⋮----
function formatTestOutput(string: string)
⋮----
// Strip colors and obfuscate any timings
⋮----
function formatTestError(string: string)
⋮----
// Strip colors and remove &quot;Check file:///workspaces/deno_std/testing/.tmp/test.ts&quot;
// as this is always output to stderr
⋮----
function testFnWithTempDir(
  fn: (t: Deno.TestContext, tempDir: string) =&gt; Promise&lt;void&gt;,
)
function testFnWithDifferentTempDir(
  fn: (
    t: Deno.TestContext,
    tempDir1: string,
    tempDir2: string,
  ) =&gt; Promise&lt;void&gt;,
)
class TestClass
⋮----
init()
get getA()
func()
⋮----
await assertSnapshot(t,
⋮----
async function testFailedAssertion&lt;T&gt;(
      snapshot: T,
      actual: T,
): Promise&lt;AssertionError&gt;
⋮----
async function runTest(test: string)
⋮----
async function runTestWithUpdateFlag(test: string)
function assertNoError(error: string)
/**
     * New snapshot
     */
⋮----
/**
     * Existing snapshot - no changes
     */
⋮----
/**
     * Existing snapshot - updates
     */
⋮----
/**
     * Existing snapshots - reverse order 1
     */
⋮----
/**
     * Existing snapshots - reverse order 2
     */
⋮----
/**
     * New snapshot
     */
⋮----
/**
     * Existing snapshot - removes one
     */
⋮----
/**
     * Existing snapshot - removes several
     */
⋮----
async function runTestWithUpdateFlag(test1: string, test2: string)
⋮----
function maskSnapshotCount(output: string)
/**
     * New snapshot
     */
⋮----
/**
     * Existing snapshot - updates
     */
⋮----
// Regression test for https://github.com/denoland/std/issues/2140
// Long strings should not be truncated with ellipsis
⋮----
// Regression test for https://github.com/denoland/std/issues/2144
// Empty arrays should be compacted
⋮----
// Regression test for https://github.com/denoland/std/issues/5155
// Asserting snapshots in update mode without required write permissions</file><file path="testing/snapshot.ts">// Copyright 2018-2025 the Deno authors. MIT license.
/** A snapshotting library.
 *
 * The `assertSnapshot` function will create a snapshot of a value and compare it
 * to a reference snapshot, which is stored alongside the test file in the
 * `__snapshots__` directory.
 *
 * ```ts
 * // example_test.ts
 * import { assertSnapshot } from &quot;@std/testing/snapshot&quot;;
 *
 * Deno.test(&quot;isSnapshotMatch&quot;, async function (t): Promise&lt;void&gt; {
 *   const a = {
 *     hello: &quot;world!&quot;,
 *     example: 123,
 *   };
 *   await assertSnapshot(t, a);
 * });
 * ```
 *
 * ```ts no-assert
 * // __snapshots__/example_test.ts.snap
 * export const snapshot: Record&lt;string, string&gt; = {};
 *
 * snapshot[&quot;isSnapshotMatch 1&quot;] = `
 * {
 *   example: 123,
 *   hello: &quot;world!&quot;,
 * }
 * `;
 * ```
 *
 * The `assertInlineSnapshot` function will create a snapshot of a value and compare it
 * to a reference snapshot, which is stored in the test file.
 *
 * ```ts
 * // example_test.ts
 * import { assertInlineSnapshot } from &quot;@std/testing/unstable-snapshot&quot;;
 *
 * Deno.test(&quot;isInlineSnapshotMatch&quot;, function (): void {
 *   const a = {
 *     hello: &quot;world!&quot;,
 *     example: 123,
 *   };
 *   assertInlineSnapshot(
 *     a,
 *     `{
 *   hello: &quot;world!&quot;,
 *   example: 123,
 * }`
 *   );
 * });
 * ```
 *
 * If the snapshot of the passed `actual` does not match the expected snapshot,
 * `assertSnapshot` and `assertInlineSnapshot` will throw an `AssertionError`,
 * causing the test to fail.
 *
 * ## Updating Snapshots:
 *
 * When adding new snapshot assertions to your test suite, or when intentionally
 * making changes which cause your snapshots to fail, you can update your snapshots
 * by running the snapshot tests in update mode. Tests can be run in update mode by
 * passing the `--update` or `-u` flag as an argument when running the test. When
 * this flag is passed, then any snapshots which do not match will be updated.
 * When this flag is not passed, tests missing snapshots will fail.
 *
 * ```sh
 * deno test --allow-all -- --update
 * ```
 *
 * In addition, `assertInlineSnapshot` defaults to formatting the test file after
 * updating snapshots. To stop this, pass command `--no-format`:
 *
 * ```sh
 * deno test --allow-all -- --update --no-format
 * ```
 *
 * ## Permissions:
 *
 * When running `assertSnapshot`, the `--allow-read` permission must be enabled, or
 * else any calls to `assertSnapshot` will fail due to insufficient permissions.
 * Additionally, when updating snapshots, the `--allow-write` permission must also
 * be enabled, as this is required in order to update snapshot files.
 *
 * The `assertSnapshot` function will only attempt to read from and write to
 * snapshot files. As such, the allow list for `--allow-read` and `--allow-write`
 * can be limited to only include existing snapshot files, if so desired.
 *
 * If no snapshots are created, `assertInlineSnapshot` does not require any
 * permissions. However, creating snapshots requires `--allow-read` and
 * `--allow-write` on any test files for which new snapshots will be added.
 * Additionally, `--allow-run` is required if any files will be formatted (which is
 * the default if `--no-format` is not specified).
 *
 * ## Options:
 *
 * The `assertSnapshot` and `assertInlineSnapshot` functions optionally accept an
 * options object.
 *
 * ```ts
 * // example_test.ts
 * import { assertSnapshot } from &quot;@std/testing/snapshot&quot;;
 *
 * Deno.test(&quot;isSnapshotMatch&quot;, async function (t): Promise&lt;void&gt; {
 *   const a = {
 *     hello: &quot;world!&quot;,
 *     example: 123,
 *   };
 *   await assertSnapshot(t, a, {
 *     // options
 *   });
 * });
 * ```
 *
 * You can also configure default options for `assertSnapshot` and `assertInlineSnapshot`.
 *
 * ```ts
 * // example_test.ts
 * import { createAssertSnapshot } from &quot;@std/testing/snapshot&quot;;
 * import { createAssertInlineSnapshot } from &quot;@std/testing/unstable-snapshot&quot;;
 *
 * const assertSnapshot = createAssertSnapshot({
 *   // options
 * });
 * const assertInlineSnapshot = createAssertInlineSnapshot({
 *   // options
 * });
 * ```
 *
 * When configuring default options like this, the resulting `assertSnapshot` or
 * `assertInlineSnapshot` function will function the same as the default function exported
 * from thesnapshot module. If passed an optional options object, this will take precedence
 * over the default options, where the value provided for an option differs.
 *
 * It is possible to &quot;extend&quot; an `assertSnapshot` or `assertInlineSnapshot` function which
 * has been configured with default options.
 *
 * ```ts
 * // example_test.ts
 * import { createAssertSnapshot } from &quot;@std/testing/snapshot&quot;;
 * import { stripAnsiCode } from &quot;@std/fmt/colors&quot;;
 *
 * const assertSnapshot = createAssertSnapshot({
 *   dir: &quot;.snaps&quot;,
 * });
 *
 * const assertMonochromeSnapshot = createAssertSnapshot&lt;string&gt;(
 *   { serializer: stripAnsiCode },
 *   assertSnapshot,
 * );
 *
 * Deno.test(&quot;isSnapshotMatch&quot;, async function (t): Promise&lt;void&gt; {
 *   const a = &quot;\x1b[32mThis green text has had its colors stripped\x1b[39m&quot;;
 *   await assertMonochromeSnapshot(t, a);
 * });
 * ```
 *
 * ```ts no-assert
 * // .snaps/example_test.ts.snap
 * export const snapshot: Record&lt;string, string&gt; = {};
 *
 * snapshot[&quot;isSnapshotMatch 1&quot;] = &quot;This green text has had its colors stripped&quot;;
 * ```
 *
 * ## Version Control:
 *
 * Snapshot testing works best when changes to snapshot files are committed
 * alongside other code changes. This allows for changes to reference snapshots to
 * be reviewed along side the code changes that caused them, and ensures that when
 * others pull your changes, their tests will pass without needing to update
 * snapshots locally.
 *
 * @module
 */
import { fromFileUrl } from &quot;@std/path/from-file-url&quot;;
import { parse } from &quot;@std/path/parse&quot;;
import { resolve } from &quot;@std/path/resolve&quot;;
import { toFileUrl } from &quot;@std/path/to-file-url&quot;;
import { ensureFile, ensureFileSync } from &quot;@std/fs/ensure-file&quot;;
import { assert } from &quot;@std/assert/assert&quot;;
import { AssertionError } from &quot;@std/assert/assertion-error&quot;;
import { equal } from &quot;@std/assert/equal&quot;;
import {
  escapeStringForJs,
  getErrorMessage,
  getIsUpdate,
  getOptions,
  getSnapshotNotMatchMessage,
  serialize,
} from &quot;./_snapshot_utils.ts&quot;;
⋮----
/** The mode of snapshot testing. */
export type SnapshotMode = &quot;assert&quot; | &quot;update&quot;;
/** The options for {@linkcode assertSnapshot}. */
export type SnapshotOptions&lt;T = unknown&gt; = {
  /**
   * Snapshot output directory. Snapshot files will be written to this directory.
   * This can be relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
  dir?: string;
  /**
   * Snapshot mode. Defaults to `assert`, unless the `-u` or `--update` flag is
   * passed, in which case this will be set to `update`. This option takes higher
   * priority than the update flag. If the `--update` flag is passed, it will be
   * ignored if the `mode` option is set.
   */
  mode?: SnapshotMode;
  /**
   * Failure message to log when the assertion fails. Specifying this option will
   * cause the diff not to be logged.
   */
  msg?: string;
  /**
   * Name of the snapshot to use in the snapshot file.
   */
  name?: string;
  /**
   * Snapshot output path. The snapshot will be written to this file. This can be
   * a path relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
  path?: string;
  /**
   * Function to use when serializing the snapshot. The default is {@linkcode serialize}.
   */
  serializer?: (actual: T) =&gt; string;
};
⋮----
/**
   * Snapshot output directory. Snapshot files will be written to this directory.
   * This can be relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
⋮----
/**
   * Snapshot mode. Defaults to `assert`, unless the `-u` or `--update` flag is
   * passed, in which case this will be set to `update`. This option takes higher
   * priority than the update flag. If the `--update` flag is passed, it will be
   * ignored if the `mode` option is set.
   */
⋮----
/**
   * Failure message to log when the assertion fails. Specifying this option will
   * cause the diff not to be logged.
   */
⋮----
/**
   * Name of the snapshot to use in the snapshot file.
   */
⋮----
/**
   * Snapshot output path. The snapshot will be written to this file. This can be
   * a path relative to the test directory or an absolute path.
   *
   * If both `dir` and `path` are specified, the `dir` option will be ignored and
   * the `path` option will be handled as normal.
   */
⋮----
/**
   * Function to use when serializing the snapshot. The default is {@linkcode serialize}.
   */
⋮----
class AssertSnapshotContext
⋮----
/**
   * Returns an instance of `AssertSnapshotContext`. This will be retrieved from
   * a cache if an instance was already created for a given snapshot file path.
   */
static fromOptions(
    testContext: Deno.TestContext,
    options: SnapshotOptions,
): AssertSnapshotContext
⋮----
constructor(snapshotFileUrl: URL)
/**
   * Asserts that `this.#currentSnapshots` has been initialized and then returns it.
   *
   * Should only be called when `this.#currentSnapshots` has already been initialized.
   */
⋮----
/**
   * Write updates to the snapshot file and log statistics.
   */
⋮----
// This occurs when `assertSnapshot` is called in &quot;assert&quot; mode but
// the snapshot doesn&apos;t exist and `assertSnapshot` is also called in
// &quot;update&quot; mode. In this case, we have nothing to write to the
// snapshot file so we can just exit early
⋮----
// deno-lint-ignore no-console
⋮----
// deno-lint-ignore no-console
⋮----
// deno-lint-ignore no-console
⋮----
/**
   * Returns `this.#currentSnapshots` and if necessary, tries to initialize it by reading existing
   * snapshots from the snapshot file. If the snapshot mode is `update` and the snapshot file does
   * not exist then it will be created.
   */
⋮----
/**
   * Register a teardown function which writes the snapshot file to disk and logs the number
   * of snapshots updated after all tests have run.
   *
   * This method can safely be called more than once and will only register the teardown
   * function once in a context.
   */
async registerTeardown()
/**
   * Gets the number of snapshots which have been created with the same name and increments
   * the count by 1.
   */
getCount(snapshotName: string)
/**
   * Get an existing snapshot by name or returns `undefined` if the snapshot does not exist.
   */
async getSnapshot(snapshotName: string, options: SnapshotOptions)
/**
   * Update a snapshot by name. Updates will be written to the snapshot file when all tests
   * have run. If the snapshot does not exist, it will be created.
   *
   * Should only be called when mode is `update`.
   */
updateSnapshot(snapshotName: string, snapshot: string)
/**
   * Get the number of updated snapshots.
   */
getUpdatedCount()
/**
   * Add a snapshot to the update queue.
   *
   * Tracks the order in which snapshots were created so that they can be written to
   * the snapshot file in the correct order.
   *
   * Should be called with each snapshot, regardless of the mode, as a future call to
   * `assertSnapshot` could cause updates to be written to the snapshot file if the
   * `update` mode is passed in the options.
   */
pushSnapshotToUpdateQueue(snapshotName: string)
/**
   * Check if exist snapshot
   */
hasSnapshot(snapshotName: string): boolean
⋮----
/**
 * Make an assertion that `actual` matches a snapshot. If the snapshot and `actual` do
 * not match, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @example Usage
 * ```ts
 * import { assertSnapshot } from &quot;@std/testing/snapshot&quot;;
 *
 * Deno.test(&quot;snapshot&quot;, async (t) =&gt; {
 *   await assertSnapshot&lt;number&gt;(t, 2);
 * });
 * ```
 * @typeParam T The type of the snapshot
 * @param context The test context
 * @param actual The actual value to compare
 * @param options The options
 */
export async function assertSnapshot&lt;T&gt;(
  context: Deno.TestContext,
  actual: T,
  options: SnapshotOptions&lt;T&gt;,
): Promise&lt;void&gt;;
/**
 * Make an assertion that `actual` matches a snapshot. If the snapshot and `actual` do
 * not match, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @example Usage
 * ```ts
 * import { assertSnapshot } from &quot;@std/testing/snapshot&quot;;
 *
 * Deno.test(&quot;snapshot&quot;, async (t) =&gt; {
 *   await assertSnapshot&lt;number&gt;(t, 2);
 * });
 * ```
 *
 * @typeParam T The type of the snapshot
 * @param context The test context
 * @param actual The actual value to compare
 * @param message The optional assertion message
 */
export async function assertSnapshot&lt;T&gt;(
  context: Deno.TestContext,
  actual: T,
  message?: string,
): Promise&lt;void&gt;;
export async function assertSnapshot(
  context: Deno.TestContext,
  actual: unknown,
  msgOrOpts?: string | SnapshotOptions&lt;unknown&gt;,
)
⋮----
function getTestName(
    context: Deno.TestContext,
    options?: SnapshotOptions,
): string
⋮----
/**
 * Create {@linkcode assertSnapshot} function with the given options.
 *
 * The specified option becomes the default for returned {@linkcode assertSnapshot}
 *
 * @example Usage
 * ```ts
 * import { createAssertSnapshot } from &quot;@std/testing/snapshot&quot;;
 *
 * const assertSnapshot = createAssertSnapshot({
 *   // Uses the custom directory for saving snapshot files.
 *   dir: &quot;my_snapshot_dir&quot;,
 * });
 *
 * Deno.test(&quot;a snapshot test case&quot;, async (t) =&gt; {
 *   await assertSnapshot(t, {
 *     foo: &quot;Hello&quot;,
 *     bar: &quot;World&quot;,
 *   });
 * })
 * ```
 *
 * @typeParam T The type of the snapshot
 * @param options The options
 * @param baseAssertSnapshot {@linkcode assertSnapshot} function implementation. Default to the original {@linkcode assertSnapshot}
 * @returns {@linkcode assertSnapshot} function with the given default options.
 */
export function createAssertSnapshot&lt;T&gt;(
  options: SnapshotOptions&lt;T&gt;,
  baseAssertSnapshot: typeof assertSnapshot = assertSnapshot,
): typeof assertSnapshot</file><file path="testing/time_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import {
  assert,
  assertAlmostEquals,
  assertEquals,
  assertInstanceOf,
  assertMatch,
  assertNotEquals,
  assertRejects,
  assertStrictEquals,
  assertThrows,
} from &quot;@std/assert&quot;;
import { FakeTime, TimeError } from &quot;./time.ts&quot;;
import { _internals } from &quot;./_time.ts&quot;;
import { assertSpyCall, spy, type SpyCall } from &quot;./mock.ts&quot;;
import { deadline, delay } from &quot;@std/async&quot;;
function fromNow(): (..._args: unknown[]) =&gt; number
⋮----
const asyncFn = async () =&gt;
⋮----
// Callback is called by `next`.
⋮----
// Callback is already called before `next` called.
⋮----
// Callbacks are cleared before `next` called.
⋮----
// Callback is partially cleared before `next` called.
⋮----
// Callback is called by `nextAsync`.
⋮----
// Callback is already called before `nextAsync` called.
⋮----
// Callbacks are cleared before `nextAsync` called.
⋮----
// Callback is partially cleared before `nextAsync` called.
⋮----
// https://github.com/denoland/std/issues/5499</file><file path="testing/time.ts">// Copyright 2018-2025 the Deno authors. MIT license.
/**
 * Utilities for mocking time while testing.
 *
 * ```ts
 * import {
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 * import { FakeTime } from &quot;@std/testing/time&quot;;
 *
 * function secondInterval(cb: () =&gt; void): number {
 *   return setInterval(cb, 1000);
 * }
 *
 * Deno.test(&quot;secondInterval calls callback every second and stops after being cleared&quot;, () =&gt; {
 *   using time = new FakeTime();
 *
 *   const cb = spy();
 *   const intervalId = secondInterval(cb);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 1);
 *   time.tick(3500);
 *   assertSpyCalls(cb, 4);
 *
 *   clearInterval(intervalId);
 *   time.tick(1000);
 *   assertSpyCalls(cb, 4);
 * });
 * ```
 *
 * @module
 */
import { RedBlackTree } from &quot;@std/data-structures/red-black-tree&quot;;
import { ascend } from &quot;@std/data-structures/comparators&quot;;
import type { DelayOptions } from &quot;@std/async/delay&quot;;
import { _internals } from &quot;./_time.ts&quot;;
⋮----
/**
 * Represents an error when trying to execute an invalid operation on fake time,
 * given the state fake time is in.
 *
 * @example Usage
 * ```ts
 * import { FakeTime, TimeError } from &quot;@std/testing/time&quot;;
 * import { assertThrows } from &quot;@std/assert&quot;;
 *
 * assertThrows(() =&gt; {
 *   const time = new FakeTime();
 *   time.restore();
 *   time.restore();
 * }, TimeError);
 * ```
 */
export class TimeError extends Error
⋮----
/** Construct TimeError.
   *
   * @param message The error message
   */
constructor(message: string)
⋮----
function fakeTimeNow()
⋮----
construct(_target, args)
⋮----
// @ts-expect-error this is a passthrough
⋮----
apply(_target, _thisArg, _args)
get(target, prop, receiver)
⋮----
interface Timer {
  id: number;
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&gt; void;
  delay: number;
  args: unknown[];
  due: number;
  repeat: boolean;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The option for {@linkcode FakeTime} */
export interface FakeTimeOptions {
  /**
   * The rate relative to real time at which fake time is updated.
   * By default time only moves forward through calling tick or setting now.
   * Set to 1 to have the fake time automatically tick forward at the same rate in milliseconds as real time.
   *
   * @default {0}
   */
  advanceRate: number;
  /**
   * The frequency in milliseconds at which fake time is updated.
   * If advanceRate is set, we will update the time every 10 milliseconds by default.
   *
   * @default {10}
   */
  advanceFrequency?: number;
}
⋮----
/**
   * The rate relative to real time at which fake time is updated.
   * By default time only moves forward through calling tick or setting now.
   * Set to 1 to have the fake time automatically tick forward at the same rate in milliseconds as real time.
   *
   * @default {0}
   */
⋮----
/**
   * The frequency in milliseconds at which fake time is updated.
   * If advanceRate is set, we will update the time every 10 milliseconds by default.
   *
   * @default {10}
   */
⋮----
interface DueNode {
  due: number;
  timers: Timer[];
}
⋮----
function fakeSetTimeout(
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&gt; void,
  delay = 0,
  // deno-lint-ignore no-explicit-any
  ...args: any[]
): number
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function fakeClearTimeout(id?: unknown)
function fakeSetInterval(
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&gt; unknown,
  delay = 0,
  // deno-lint-ignore no-explicit-any
  ...args: any[]
): number
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function fakeClearInterval(id?: unknown)
function setTimer(
  // deno-lint-ignore no-explicit-any
  callback: (...args: any[]) =&gt; void,
  delay = 0,
  args: unknown[],
  repeat = false,
): number
⋮----
// deno-lint-ignore no-explicit-any
⋮----
function fakeAbortSignalTimeout(delay: number): AbortSignal
function overrideGlobals()
function restoreGlobals()
⋮----
function nextDueNode(): DueNode | null
⋮----
/**
 * Overrides the real Date object and timer functions with fake ones that can be
 * controlled through the fake time instance.
 *
 * Note: there is no setter for the `start` property, as it cannot be changed
 * after initialization.
 *
 * @example Usage
 * ```ts
 * import {
 *   assertSpyCalls,
 *   spy,
 * } from &quot;@std/testing/mock&quot;;
 * import { FakeTime } from &quot;@std/testing/time&quot;;
 *
 * function secondInterval(cb: () =&gt; void): number {
 *   return setInterval(cb, 1000);
 * }
 *
 * Deno.test(&quot;secondInterval calls callback every second and stops after being cleared&quot;, () =&gt; {
 *   using time = new FakeTime();
 *
 *   const cb = spy();
 *   const intervalId = secondInterval(cb);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 0);
 *   time.tick(500);
 *   assertSpyCalls(cb, 1);
 *   time.tick(3500);
 *   assertSpyCalls(cb, 4);
 *
 *   clearInterval(intervalId);
 *   time.tick(1000);
 *   assertSpyCalls(cb, 4);
 * });
 * ```
 */
export class FakeTime
⋮----
/**
   * Construct a FakeTime object. This overrides the real Date object and timer functions with fake ones that can be
   * controlled through the fake time instance.
   *
   * @param start The time to simulate. The default is the current time.
   * @param options The options
   *
   * @throws {TimeError} If time is already faked
   * @throws {TypeError} If the start is invalid
   */
constructor(
    start?: number | string | Date | null,
    options?: FakeTimeOptions,
)
/**
   * Restores real time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * {
   *   using fakeTime = new FakeTime();
   *
   *   assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   *   // test timer related things.
   *
   *   // You don&apos;t need to call fakeTime.restore() explicitly
   *   // as it&apos;s implicitly called via the [Symbol.dispose] method
   *   // when declared with `using`.
   * }
   *
   * assertEquals(globalThis.setTimeout, setTimeout);
   * ```
   */
⋮----
/**
   * Restores real time.
   *
   * @throws {TimeError} If time is already restored
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * const fakeTime = new FakeTime();
   *
   * assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   * FakeTime.restore();
   *
   * assertEquals(globalThis.setTimeout, setTimeout);
   * ```
   */
static restore()
/**
   * Restores real time temporarily until callback returns and resolves.
   *
   * @throws {TimeError} If time is not faked
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * const fakeTime = new FakeTime();
   *
   * assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   * FakeTime.restoreFor(() =&gt; {
   *   assertEquals(globalThis.setTimeout, setTimeout);
   * });
   * ```
   *
   * @typeParam T The returned value type of the callback
   * @param callback The callback to be called while FakeTime being restored
   * @param args The arguments to pass to the callback
   * @returns The returned value from the callback
   */
static restoreFor&lt;T&gt;(
    // deno-lint-ignore no-explicit-any
    callback: (...args: any[]) =&gt; Promise&lt;T&gt; | T,
    // deno-lint-ignore no-explicit-any
    ...args: any[]
): Promise&lt;T&gt;
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/**
   * The number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * assertEquals(fakeTime.now, 15_000);
   *
   * fakeTime.tick(5_000);
   *
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @returns The number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time
   */
get now(): number
/**
   * Set the current time. It will call any functions waiting to be called between the current and new fake time.
   * If the timer callback throws, time will stop advancing forward beyond that timer.
   *
   * @throws {RangeError} If the time goes backwards
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * assertEquals(fakeTime.now, 15_000);
   *
   * fakeTime.now = 35_000;
   *
   * assertEquals(fakeTime.now, 35_000);
   * ```
   *
   * @param value The current time (in milliseconds)
   */
set now(value: number)
/**
   * The initial number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * assertEquals(fakeTime.start, 15_000);
   * ```
   *
   * @returns The initial number of milliseconds elapsed since the epoch (January 1, 1970 00:00:00 UTC) for the fake time.
   */
get start(): number
/**
   * Resolves after the given number of milliseconds using real time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * await fakeTime.delay(500); // wait 500 ms in real time.
   *
   * assertEquals(fakeTime.now, 15_000); // The simulated time doesn&apos;t advance.
   * ```
   *
   * @param ms The milliseconds to delay
   * @param options The options
   */
async delay(ms: number, options: DelayOptions =
⋮----
const abort = ()
const done = () =&gt;
⋮----
/**
   * Runs all pending microtasks.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assert } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called = false;
   *
   * Promise.resolve().then(() =&gt; { called = true });
   *
   * await fakeTime.runMicrotasks();
   *
   * assert(called);
   * ```
   */
async runMicrotasks()
/**
   * Adds the specified number of milliseconds to the fake time.
   * This will call any functions waiting to be called between the current and new fake time.
   *
   * @example Usage
   * ```ts
   * import {
   *   assertSpyCalls,
   *   spy,
   * } from &quot;@std/testing/mock&quot;;
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   *
   * function secondInterval(cb: () =&gt; void): number {
   *   return setInterval(cb, 1000);
   * }
   *
   * Deno.test(&quot;secondInterval calls callback every second and stops after being cleared&quot;, () =&gt; {
   *   using time = new FakeTime();
   *
   *   const cb = spy();
   *   const intervalId = secondInterval(cb);
   *   assertSpyCalls(cb, 0);
   *   time.tick(500);
   *   assertSpyCalls(cb, 0);
   *   time.tick(500);
   *   assertSpyCalls(cb, 1);
   *   time.tick(3500);
   *   assertSpyCalls(cb, 4);
   *
   *   clearInterval(intervalId);
   *   time.tick(1000);
   *   assertSpyCalls(cb, 4);
   * });
   * ```
   *
   * @param ms The milliseconds to advance
   */
tick(ms = 0)
/**
   * Runs all pending microtasks then adds the specified number of milliseconds to the fake time.
   * This will call any functions waiting to be called between the current and new fake time.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assert, assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called = false;
   *
   * Promise.resolve().then(() =&gt; { called = true });
   *
   * await fakeTime.tickAsync(5_000);
   *
   * assert(called);
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @param ms The milliseconds to advance
   */
async tickAsync(ms = 0)
/**
   * Advances time to when the next scheduled timer is due.
   * If there are no pending timers, time will not be changed.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assert, assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called = false;
   *
   * setTimeout(() =&gt; { called = true }, 5000);
   *
   * fakeTime.next();
   *
   * assert(called);
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @returns `true` when there is a scheduled timer and `false` when there is not.
   */
next(): boolean
/**
   * Runs all pending microtasks then advances time to when the next scheduled timer is due.
   * If there are no pending timers, time will not be changed.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assert, assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let called0 = false;
   * let called1 = false;
   *
   * setTimeout(() =&gt; { called0 = true }, 5000);
   * Promise.resolve().then(() =&gt; { called1 = true });
   *
   * await fakeTime.nextAsync();
   *
   * assert(called0);
   * assert(called1);
   * assertEquals(fakeTime.now, 20_000);
   * ```
   *
   * @returns `true` if the pending timers existed and the time advanced, `false` if there was no pending timer and the time didn&apos;t advance.
   */
async nextAsync(): Promise&lt;boolean&gt;
/**
   * Advances time forward to the next due timer until there are no pending timers remaining.
   * If the timers create additional timers, they will be run too. If there is an interval,
   * time will keep advancing forward until the interval is cleared.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let count = 0;
   *
   * setTimeout(() =&gt; { count++ }, 5_000);
   * setTimeout(() =&gt; { count++ }, 15_000);
   * setTimeout(() =&gt; { count++ }, 35_000);
   *
   * fakeTime.runAll();
   *
   * assertEquals(count, 3);
   * assertEquals(fakeTime.now, 50_000);
   * ```
   */
runAll()
/**
   * Advances time forward to the next due timer until there are no pending timers remaining.
   * If the timers create additional timers, they will be run too. If there is an interval,
   * time will keep advancing forward until the interval is cleared.
   * Runs all pending microtasks before each timer.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals } from &quot;@std/assert&quot;;
   *
   * const fakeTime = new FakeTime(15_000);
   *
   * let count = 0;
   *
   * setTimeout(() =&gt; { count++ }, 5_000);
   * setTimeout(() =&gt; { count++ }, 15_000);
   * setTimeout(() =&gt; { count++ }, 35_000);
   * Promise.resolve().then(() =&gt; { count++ });
   *
   * await fakeTime.runAllAsync();
   *
   * assertEquals(count, 4);
   * assertEquals(fakeTime.now, 50_000);
   * ```
   */
async runAllAsync()
/**
   * Restores time related global functions to their original state.
   *
   * @example Usage
   * ```ts
   * import { FakeTime } from &quot;@std/testing/time&quot;;
   * import { assertEquals, assertNotEquals } from &quot;@std/assert&quot;;
   *
   * const setTimeout = globalThis.setTimeout;
   *
   * const fakeTime = new FakeTime(); // global timers are now faked
   *
   * assertNotEquals(globalThis.setTimeout, setTimeout);
   *
   * fakeTime.restore(); // timers are restored
   *
   * assertEquals(globalThis.setTimeout, setTimeout);
   * ```
   */
restore()</file><file path="testing/types_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
// Copyright @dsherret and dsherret/conditional-type-checks contributors. All rights reserved. MIT license.
// deno-lint-ignore-file no-explicit-any ban-types
import {
  type Assert,
  type AssertFalse,
  type AssertTrue,
  assertType,
  type Has,
  type IsAny,
  type IsExact,
  type IsNever,
  type IsNullable,
  type IsUnknown,
  type NotHas,
} from &quot;./types.ts&quot;;
// IsNullable
⋮----
// matching
⋮----
assertType&lt;IsNullable&lt;null | undefined&gt;&gt;(true); // maybe this shouldn&apos;t be true?
// not matching
⋮----
// IsExact
⋮----
class _Class&lt;T&gt;
⋮----
constructor(prop: T)
⋮----
// matching
⋮----
assertType&lt;IsExact&lt;any, any&gt;&gt;(true); // ok to have any for both
⋮----
// not matching
⋮----
assertType&lt;IsExact&lt;{ prop: string | undefined }, { prop?: string }&gt;&gt;(false); // these are different
⋮----
// Has
⋮----
// matching
⋮----
assertType&lt;Has&lt;string | number, Date | string&gt;&gt;(true); // maybe?
⋮----
// not matching
⋮----
// NotHas
⋮----
// matching
⋮----
// not matching
⋮----
assertType&lt;NotHas&lt;string | number, Date | string&gt;&gt;(false); // should be true?
⋮----
// IsAny
⋮----
// matching
⋮----
// not matching
⋮----
// tests for issue #3 (IsAny resolving to boolean)
⋮----
// IsNever
⋮----
// matching
⋮----
// not matching
⋮----
// IsUnknown
⋮----
// matching
⋮----
// not matching
⋮----
// AssertTrue
⋮----
type Test = AssertTrue&lt;IsNever&lt;never&gt;&gt;;
⋮----
// AssertFalse
⋮----
type Test = AssertFalse&lt;IsNever&lt;string&gt;&gt;;
⋮----
// Assert
⋮----
type Test =
    | Assert&lt;Has&lt;string | number, number&gt;, true&gt;
    | Assert&lt;Has&lt;string | number, Date&gt;, false&gt;;
⋮----
// Recursive types
⋮----
type RecursiveType1 = string | number | Date | RecursiveType1[];
⋮----
type RecursiveType2 = {
    a: string;
    prop: RecursiveType2;
    sub: {
      prop: RecursiveType2;
      other: RecursiveType1;
    };
  };</file><file path="testing/types.ts">// Copyright 2018-2025 the Deno authors. MIT license.
// Copyright @dsherret and dsherret/conditional-type-checks contributors. All rights reserved. MIT license.
/**
 * Testing utilities for types.
 *
 * ```ts expect-error ignore
 * import { assertType, IsExact, IsNullable } from &quot;@std/testing/types&quot;;
 *
 * const result = &quot;some result&quot; as string | number;
 *
 * // compile error if the type of `result` is not exactly `string | number`
 * assertType&lt;IsExact&lt;typeof result, string | number&gt;&gt;(true);
 *
 * // causes a compile error that `true` is not assignable to `false`
 * assertType&lt;IsNullable&lt;string&gt;&gt;(true); // error: string is not nullable
 * ```
 *
 * @module
 */
/**
 * Asserts at compile time that the provided type argument&apos;s type resolves to the expected boolean literal type.
 *
 * @example Usage
 * ```ts expect-error ignore
 * import { assertType, IsExact, IsNullable } from &quot;@std/testing/types&quot;;
 *
 * const result = &quot;some result&quot; as string | number;
 *
 * // compile error if the type of `result` is not exactly `string | number`
 * assertType&lt;IsExact&lt;typeof result, string | number&gt;&gt;(true);
 *
 * // causes a compile error that `true` is not assignable to `false`
 * assertType&lt;IsNullable&lt;string&gt;&gt;(true); // error: string is not nullable
 * ```
 *
 * @typeParam T The expected type (`true` or `false`)
 * @param expectTrue True if the passed in type argument resolved to true.
 */
export function assertType&lt;T extends boolean&gt;(
⋮----
// deno-lint-ignore no-unused-vars
⋮----
/**
 * Asserts at compile time that the provided type argument&apos;s type resolves to true.
 *
 * @example Usage
 * ```ts
 * import { AssertTrue, Has, IsNullable } from &quot;@std/testing/types&quot;;
 *
 * const result = 1 as string | number | null;
 *
 * type doTest = AssertTrue&lt;Has&lt;typeof result, string&gt; | IsNullable&lt;typeof result&gt;&gt;;
 * ```
 *
 * @typeParam T The type to assert is true.
 */
export type AssertTrue&lt;T extends true&gt; = never;
/**
 * Asserts at compile time that the provided type argument&apos;s type resolves to false.
 *
 * @example Usage
 * ```ts
 * import { AssertFalse, IsNever } from &quot;@std/testing/types&quot;;
 *
 * const result = 1 as string | number | null;
 *
 * type doTest = AssertFalse&lt;IsNever&lt;typeof result&gt;&gt;;
 * ```
 *
 * @typeParam T The type to assert is false.
 */
export type AssertFalse&lt;T extends false&gt; = never;
/**
 * Asserts at compile time that the provided type argument&apos;s type resolves to the expected boolean literal type.
 *
 * @example Usage
 * ```ts
 * import { Assert, Has } from &quot;@std/testing/types&quot;;
 *
 * const result = 1 as string | number | null;
 *
 * type doTest = Assert&lt;Has&lt;typeof result, number&gt;, true&gt;;
 * ```
 *
 * @typeParam T The type to assert is the expected boolean literal type.
 * @typeParam Expected The expected boolean literal type.
 */
export type Assert&lt;T extends boolean, Expected extends T&gt; = never;
/**
 * Checks if type `T` has the specified type `U`.
 *
 * @example Usage
 * ```ts
 * import { assertType, Has } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;Has&lt;string | number, string&gt;&gt;(true);
 * assertType&lt;Has&lt;any, number&gt;&gt;(true);
 *
 * assertType&lt;Has&lt;string | number, Date&gt;&gt;(false);
 * assertType&lt;Has&lt;string, number&gt;&gt;(false);
 * assertType&lt;Has&lt;number, any&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it has the specified type `U`.
 * @typeParam U The type to check if it is in the type `T`.
 */
export type Has&lt;T, U&gt; = IsAny&lt;T&gt; extends true ? true
  : IsAny&lt;U&gt; extends true ? false
  : Extract&lt;T, U&gt; extends never ? false
  : true;
/**
 * Checks if type `T` does not have the specified type `U`.
 *
 * @example Usage
 * ```ts
 * import { assertType, NotHas } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;NotHas&lt;string | number, Date&gt;&gt;(true);
 * assertType&lt;NotHas&lt;string, number&gt;&gt;(true);
 * assertType&lt;NotHas&lt;number, any&gt;&gt;(true);
 *
 * assertType&lt;NotHas&lt;string | number, string&gt;&gt;(false);
 * assertType&lt;NotHas&lt;any, number&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it does not have the specified type `U`.
 * @typeParam U The type to check if it is not in the type `T`.
 */
export type NotHas&lt;T, U&gt; = Has&lt;T, U&gt; extends false ? true : false;
/**
 * Checks if type `T` is possibly null or undefined.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsNullable } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;IsNullable&lt;string | null&gt;&gt;(true);
 * assertType&lt;IsNullable&lt;string | undefined&gt;&gt;(true);
 * assertType&lt;IsNullable&lt;null | undefined&gt;&gt;(true);
 *
 * assertType&lt;IsNullable&lt;string&gt;&gt;(false);
 * assertType&lt;IsNullable&lt;any&gt;&gt;(false);
 * assertType&lt;IsNullable&lt;never&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is nullable.
 */
export type IsNullable&lt;T&gt; = Extract&lt;T, null | undefined&gt; extends never ? false
  : true;
/**
 * Checks if type `T` exactly matches type `U`.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsExact } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;IsExact&lt;string | number, string | number&gt;&gt;(true);
 * assertType&lt;IsExact&lt;any, any&gt;&gt;(true); // ok to have any for both
 * assertType&lt;IsExact&lt;never, never&gt;&gt;(true);
 * assertType&lt;IsExact&lt;{ prop: string }, { prop: string }&gt;&gt;(true);
 *
 * assertType&lt;IsExact&lt;string | number | Date, string | number&gt;&gt;(false);
 * assertType&lt;IsExact&lt;string, string | number&gt;&gt;(false);
 * assertType&lt;IsExact&lt;string | undefined, string&gt;&gt;(false);
 * assertType&lt;IsExact&lt;string | undefined, any | string&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it exactly matches type `U`.
 * @typeParam U The type to check if it exactly matches type `T`.
 */
export type IsExact&lt;T, U&gt; = ParametersAndReturnTypeMatches&lt;
  FlatType&lt;AnyToBrand&lt;T&gt;&gt;,
  FlatType&lt;AnyToBrand&lt;U&gt;&gt;
&gt; extends true ? ParametersAndReturnTypeMatches&lt;
    FlatType&lt;DeepPrepareIsExact&lt;T&gt;&gt;,
    FlatType&lt;DeepPrepareIsExact&lt;U&gt;&gt;
  &gt; extends true ? true
  : false
  : false;
/** @internal */
export type DeepPrepareIsExact&lt;T, VisitedTypes = never&gt; = {
  // make optional properties required
  [P in keyof T]-?: IsAny&lt;T[P]&gt; extends true ? AnyBrand
    : DeepPrepareIsExactProp&lt;T[P], T, VisitedTypes&gt;;
};
⋮----
// make optional properties required
⋮----
/** @internal */
export type DeepPrepareIsExactProp&lt;Prop, Parent, VisitedTypes&gt; = Prop extends
  VisitedTypes
  // recursive, bail
  ? Prop
  // not recursive, keep going and add the parent type as a visited type
  : DeepPrepareIsExact&lt;Prop, VisitedTypes | Parent&gt;;
⋮----
// recursive, bail
⋮----
// not recursive, keep going and add the parent type as a visited type
⋮----
/**
 * Checks if type `T` is the `any` type.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsAny } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;IsAny&lt;any&gt;&gt;(true);
 * assertType&lt;IsAny&lt;unknown&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is the `any` type.
 */
// https://stackoverflow.com/a/49928360/3406963
export type IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false;
/**
 * Checks if type `T` is the `never` type.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsNever } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;IsNever&lt;never&gt;&gt;(true);
 * assertType&lt;IsNever&lt;unknown&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is the `never` type.
 */
export type IsNever&lt;T&gt; = [T] extends [never] ? true : false;
/**
 * Checks if type `T` is the `unknown` type.
 *
 * @example Usage
 * ```ts
 * import { assertType, IsUnknown } from &quot;@std/testing/types&quot;;
 *
 * assertType&lt;IsUnknown&lt;unknown&gt;&gt;(true);
 * assertType&lt;IsUnknown&lt;never&gt;&gt;(false);
 * ```
 *
 * @typeParam T The type to check if it is the `unknown` type.
 */
export type IsUnknown&lt;T&gt; = unknown extends T
  ? ([T] extends [null] ? false : true)
  : false;
/**
 * The internal utility type to match the given types as return types.
 *
 * @internal
 */
export type ParametersAndReturnTypeMatches&lt;T, U&gt; = Matches&lt;
  &lt;X&gt;(_: T) =&gt; X extends T ? 1 : 2,
  &lt;X&gt;(_: U) =&gt; X extends U ? 1 : 2
&gt;;
/**
 * The internal utility type to match the given types as tuples.
 *
 * @internal
 */
export type TupleMatches&lt;T, U&gt; = Matches&lt;[T], [U]&gt;;
/**
 * The internal utility type to match the given types.
 *
 * @internal
 */
export type Matches&lt;T, U&gt; = T extends U ? U extends T ? true : false : false;
/**
 * The utility type to convert any to {@linkcode AnyBrand}.
 *
 * @internal
 */
export type AnyToBrand&lt;T&gt; = IsAny&lt;T&gt; extends true ? AnyBrand : T;
/**
 * The utility type to represent any type.
 *
 * @internal
 */
export type AnyBrand = { __conditionalTypeChecksAny__: undefined };
/**
 * The utility type to flatten record types.
 *
 * @internal
 */
export type FlatType&lt;T&gt; = T extends Record&lt;PropertyKey, unknown&gt;
  ? { [K in keyof T]: FlatType&lt;T[K]&gt; }
  : T;</file><file path="testing/unstable_bdd_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { assertEquals } from &quot;@std/assert&quot;;</file><file path="testing/unstable_bdd.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { globalSanitizersState } from &quot;./_test_suite.ts&quot;;
/** Options for {@linkcode configureGlobalSanitizers}. */
export type ConfigureGlobalSanitizersOptions = {
  sanitizeOps?: boolean;
  sanitizeResources?: boolean;
  sanitizeExit?: boolean;
};
/**
 * Configures the global sanitizers.
 * @param options The options
 * @example Usage
 * ```ts no-assert
 * import { configureGlobalSanitizers } from &quot;@std/testing/unstable-bdd&quot;;
 * configureGlobalSanitizers({ sanitizeResources: false })
 * ```
 */
export function configureGlobalSanitizers(
  options: ConfigureGlobalSanitizersOptions,
): void</file><file path="testing/unstable_snapshot_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { stripAnsiCode } from &quot;@std/fmt/colors&quot;;
import { dirname, fromFileUrl, join, toFileUrl } from &quot;@std/path&quot;;
import { assertEquals } from &quot;@std/assert&quot;;
import {
  assertInlineSnapshot,
  createAssertInlineSnapshot,
} from &quot;./unstable_snapshot.ts&quot;;
import { LINT_SUPPORTED } from &quot;./_snapshot_utils.ts&quot;;
⋮----
class TestClass
⋮----
init()
get getA()
func()
⋮----</file><file path="testing/unstable_snapshot.ts">// Copyright 2018-2025 the Deno authors. MIT license.
// @ts-nocheck Deno.lint namespace does not pass type checking in Deno 1.x
import type { SnapshotOptions } from &quot;./snapshot.ts&quot;;
import { AssertionError } from &quot;@std/assert/assertion-error&quot;;
import { equal } from &quot;@std/assert/equal&quot;;
import {
  escapeStringForJs,
  getIsUpdate,
  getOptions,
  getSnapshotNotMatchMessage,
  LINT_SUPPORTED,
  serialize,
} from &quot;./_snapshot_utils.ts&quot;;
/**
 * The options for {@linkcode assertInlineSnapshot}.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 */
export interface InlineSnapshotOptions&lt;T = unknown&gt;
  extends Pick&lt;SnapshotOptions&lt;T&gt;, &quot;msg&quot; | &quot;serializer&quot;&gt; {}
interface ErrorLocation {
  lineNumber: number;
  columnNumber: number;
}
interface SnapshotUpdateRequest {
  fileName: string;
  lineNumber: number;
  columnNumber: number;
  actualSnapshot: string;
}
// See https://v8.dev/docs/stack-trace-api
type V8Error = typeof Error &amp; {
  prepareStackTrace(error: Error, structuredStackTrace: CallSite[]): unknown;
};
⋮----
prepareStackTrace(error: Error, structuredStackTrace: CallSite[]): unknown;
⋮----
// See https://v8.dev/docs/stack-trace-api
interface CallSite {
  isEval(): boolean;
  getFileName(): string | null;
  getLineNumber(): number | null;
  getColumnNumber(): number | null;
}
⋮----
isEval(): boolean;
getFileName(): string | null;
getLineNumber(): number | null;
getColumnNumber(): number | null;
⋮----
function makeSnapshotUpdater(
  updateRequests: SnapshotUpdateRequest[],
): Deno.lint.Plugin
⋮----
create(context)
⋮----
// TODO(WWRS): Add \u2028 and \u2029 once Deno counts them as line breaks
⋮----
// Since lineNumber is 1-indexed, subtract 1 to convert to 0-indexed.
// Then fetch the line break before this line, which is the (n-1)th break,
// or 0 if this is the top line (index 0).
⋮----
// Fetching all functions lets us support createAssertInlineSnapshot
⋮----
fix(fixer)
⋮----
function updateSnapshots()
⋮----
// Apply the fixes in order
⋮----
// deno-lint-ignore no-console
⋮----
/**
 * Make an assertion that `actual` matches `expectedSnapshot`. If they do not match,
 * then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts no-assert
 * import { assertInlineSnapshot } from &quot;@std/testing/unstable-snapshot&quot;;
 *
 * Deno.test(&quot;snapshot&quot;, () =&gt; {
 *   assertInlineSnapshot&lt;number&gt;(2, `2`);
 * });
 * ```
 * @typeParam T The type of the snapshot
 * @param actual The actual value to compare
 * @param expectedSnapshot The expected snapshot, or \`CREATE\` to create
 * @param options The options
 */
export function assertInlineSnapshot&lt;T&gt;(
  actual: T,
  expectedSnapshot: string,
  options?: InlineSnapshotOptions&lt;T&gt;,
): void;
/**
 * Make an assertion that `actual` matches `expectedSnapshot`. If they do not match,
 * then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the same type.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts no-assert
 * import { assertInlineSnapshot } from &quot;@std/testing/unstable-snapshot&quot;;
 *
 * Deno.test(&quot;snapshot&quot;, () =&gt; {
 *   assertInlineSnapshot&lt;number&gt;(2, `2`);
 * });
 * ```
 * @typeParam T The type of the snapshot
 * @param actual The actual value to compare
 * @param expectedSnapshot The expected snapshot, or \`CREATE\` to create
 * @param message The optional assertion message
 */
export function assertInlineSnapshot&lt;T&gt;(
  actual: T,
  expectedSnapshot: string,
  message?: string,
): void;
export function assertInlineSnapshot(
  actual: unknown,
  expectedSnapshot: string,
  msgOrOpts?: string | InlineSnapshotOptions&lt;unknown&gt;,
): void
⋮----
// TODO(WWRS): dedent expectedSnapshot to allow snapshots to look nicer
⋮----
// Capture the stack that comes after this function.
⋮----
// Forcibly access the stack, and note it down
⋮----
/**
 * Create {@linkcode assertInlineSnapshot} function with the given options.
 *
 * The specified option becomes the default for returned {@linkcode assertInlineSnapshot}
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts no-assert
 * import { createAssertInlineSnapshot } from &quot;@std/testing/unstable-snapshot&quot;;
 *
 * const assertInlineSnapshot = createAssertInlineSnapshot({
 *   serializer: JSON.stringify,
 * });
 *
 * Deno.test(&quot;a snapshot test case&quot;, () =&gt; {
 *   assertInlineSnapshot(
 *     { foo: &quot;Hello&quot;, bar: undefined },
 *     `{&quot;foo&quot;:&quot;Hello&quot;}`
 *   );
 * })
 * ```
 *
 * @typeParam T The type of the snapshot
 * @param options The options
 * @param baseAssertSnapshot {@linkcode assertInlineSnapshot} function implementation. Default to the original {@linkcode assertInlineSnapshot}
 * @returns {@linkcode assertInlineSnapshot} function with the given default options.
 */
export function createAssertInlineSnapshot&lt;T&gt;(
  options: InlineSnapshotOptions&lt;T&gt;,
  baseAssertSnapshot: typeof assertInlineSnapshot = assertInlineSnapshot,
): typeof assertInlineSnapshot</file><file path="testing/unstable_stub_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { assertEquals, assertThrows } from &quot;@std/assert&quot;;
import {
  assertSpyCall,
  assertSpyCallArg,
  assertSpyCalls,
  MockError,
  returnsNext,
} from &quot;./mock.ts&quot;;
import { Point, type PointWithExtra } from &quot;./_test_utils.ts&quot;;
import { type Stub, stub } from &quot;./unstable_stub.ts&quot;;
⋮----
// This doesn&apos;t test any runtime code, only if the TypeScript types are correct.
⋮----
// @ts-expect-error Stubbing with incorrect argument types should cause a type error
⋮----
// @ts-expect-error Stubbing with an incorrect return type should cause a type error
⋮----
// Stubbing without argument types infers them from the real function
⋮----
// `toExponential()` only exists on `number`, so this will error if _x is not a number
⋮----
// `toLowerCase()` only exists on `string`, so this will error if _y is not a string
⋮----
// Stubbing with returnsNext() should not give any type errors
⋮----
// Stubbing without argument types should not cause any type errors:
⋮----
// Check if the returned type is correct:
⋮----
// @ts-expect-error Test if passing incorrect argument types causes an error
⋮----
// @ts-expect-error Test if passing incorrect return type causes an error
⋮----
// Calling assertSpyCall with the correct types should not cause any type errors
⋮----
fn()
⋮----
// deno-lint-ignore no-explicit-any
⋮----
const obj =</file><file path="testing/unstable_stub.ts">// Copyright 2018-2025 the Deno authors. MIT license.
import { isSpy, registerMock, unregisterMock } from &quot;./_mock_utils.ts&quot;;
import {
  type GetParametersFromProp,
  type GetReturnFromProp,
  type MethodSpy,
  MockError,
  type Spy,
  spy,
  type SpyCall,
} from &quot;./mock.ts&quot;;
/** An instance method replacement that records all calls made to it. */
export interface Stub&lt;
  // deno-lint-ignore no-explicit-any
  Self = any,
  // deno-lint-ignore no-explicit-any
  Args extends unknown[] = any[],
  // deno-lint-ignore no-explicit-any
  Return = any,
&gt; extends MethodSpy&lt;Self, Args, Return&gt; {
  /** The function that is used instead of the original. */
  fake: (this: Self, ...args: Args) =&gt; Return;
}
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
// deno-lint-ignore no-explicit-any
⋮----
/** The function that is used instead of the original. */
⋮----
/**
 * Replaces an instance method with a Stub with empty implementation.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCalls } from &quot;@std/testing/mock&quot;;
 * import { stub } from &quot;@std/testing/unstable-stub&quot;;
 *
 * const obj = {
 *   method() {
 *     // some inconventient feature for testing
 *   },
 * };
 *
 * const methodStub = stub(obj, &quot;method&quot;);
 *
 * for (const _ of Array(5)) {
 *   obj.method();
 * }
 *
 * assertSpyCalls(methodStub, 5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @returns The stub function which replaced the original.
 */
export function stub&lt;
  Self,
  Prop extends keyof Self,
&gt;(
  self: Self,
  property: Prop,
): Stub&lt;Self, GetParametersFromProp&lt;Self, Prop&gt;, GetReturnFromProp&lt;Self, Prop&gt;&gt;;
/**
 * Replaces an instance method with a Stub with the given implementation.
 *
 * @example Usage
 * ```ts
 * import { stub } from &quot;@std/testing/unstable-stub&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * const obj = {
 *   method(): number {
 *     return Math.random();
 *   },
 * };
 *
 * const methodStub = stub(obj, &quot;method&quot;, () =&gt; 0.5);
 *
 * assertEquals(obj.method(), 0.5);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @param func The fake implementation of the function.
 * @returns The stub function which replaced the original.
 */
export function stub&lt;
  Self,
  Prop extends keyof Self,
&gt;(
  self: Self,
  property: Prop,
  func: (
    this: Self,
    ...args: GetParametersFromProp&lt;Self, Prop&gt;
  ) =&gt; GetReturnFromProp&lt;Self, Prop&gt;,
): Stub&lt;Self, GetParametersFromProp&lt;Self, Prop&gt;, GetReturnFromProp&lt;Self, Prop&gt;&gt;;
/**
 * Replaces an instance property setter or getter with a Stub with the given implementation.
 *
 * @example Usage
 * ```ts
 * import { assertSpyCalls } from &quot;@std/testing/mock&quot;;
 * import { stub } from &quot;@std/testing/unstable-stub&quot;;
 * import { assertEquals } from &quot;@std/assert&quot;;
 *
 * const obj = {
 *  prop: &quot;foo&quot;,
 * };
 *
 * const getterStub = stub(obj, &quot;prop&quot;, {
 *  get: function () {
 *    return &quot;bar&quot;;
 *  },
 * });
 *
 * assertEquals(obj.prop, &quot;bar&quot;);
 * assertSpyCalls(getterStub.get, 1);
 * ```
 *
 * @typeParam Self The self type of the instance to replace a method of.
 * @typeParam Prop The property of the instance to replace.
 * @param self The instance to replace a method of.
 * @param property The property of the instance to replace.
 * @param descriptor The javascript property descriptor with fake implementation of the getter and setter.
 * @returns The stub with get and set properties which are spys of the setter and getter.
 */
export function stub&lt;Self, Prop extends keyof Self&gt;(
export function stub&lt;Self, Args extends unknown[], Return&gt;(
  self: Self,
  property: keyof Self,
  descriptorOrFunction?:
    | ((this: Self, ...args: Args) =&gt; Return)
    | Omit&lt;PropertyDescriptor, &quot;configurable&quot;&gt;,
): Stub&lt;Self, Args, Return&gt;</file><file path="testing/unstable_types_test.ts">// Copyright 2018-2025 the Deno authors. MIT license.
// deno-lint-ignore-file
import { assertType } from &quot;./types.ts&quot;;
import type { IsMutuallyAssignable } from &quot;./unstable_types.ts&quot;;
// IsMutuallyAssignable
⋮----
// matching
⋮----
// not matching</file><file path="testing/unstable_types.ts">// Copyright 2018-2025 the Deno authors. MIT license.
/**
 * Checks if the actual type `A` is assignable to the expected type `E`, and
 * vice versa.
 *
 * This is often less strict than `IsExact` because the two type parameters are
 * allowed to have a different structure as long as they are assignable to each
 * other. This is often more strict than `Has` because none of the two type
 * parameters may be a union that contains the other, as this would fail the
 * check for mutual assignability.
 *
 * @example Usage
 * ```ts
 * import { assertType } from &quot;@std/testing/types&quot;;
 * import type { IsMutuallyAssignable } from &quot;@std/testing/unstable-types&quot;;
 *
 * // false because E is not assignable to A
 * assertType&lt;IsMutuallyAssignable&lt;string &amp; RegExpMatchArray, string&gt;&gt;(false);
 * // false because A is not assignable to E
 * assertType&lt;IsMutuallyAssignable&lt;string | RegExpMatchArray, string&gt;&gt;(false);
 * // true because both types are assignable to each other
 * assertType&lt;IsMutuallyAssignable&lt;string | (string &amp; RegExpMatchArray), string&gt;&gt;(true);
 * ```
 */
export type IsMutuallyAssignable&lt;A, E&gt; = [E] extends [A]
  ? [A] extends [E] ? true : false
  : false;</file></files></repomix>